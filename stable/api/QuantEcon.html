<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>QuantEcon · QuantEcon.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/highlightjs/default.css" rel="stylesheet" type="text/css"/><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>QuantEcon.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" action="../search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../index.html">Home</a></li><li><span class="toctext">API</span><ul><li class="current"><a class="toctext" href="QuantEcon.html">QuantEcon</a><ul class="internal"><li><a class="toctext" href="#Index-1">Index</a></li><li><a class="toctext" href="#Exported-1">Exported</a></li><li><a class="toctext" href="#Internal-1">Internal</a></li></ul></li></ul></li><li><a class="toctext" href="../man/contributing.html">Contributing</a></li></ul></nav><article id="docs"><header><nav><ul><li>API</li><li><a href="QuantEcon.html">QuantEcon</a></li></ul><a class="edit-page" href="https://github.com/QuantEcon/QuantEcon.jl/tree/f744b5bd0dbe0f65cf0ff32bc5a744948435e4ec/docs/src/api/QuantEcon.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>QuantEcon</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="QuantEcon-1" href="#QuantEcon-1">QuantEcon</a></h1><p>API documentation</p><ul><li><a href="QuantEcon.html#QuantEcon-1">QuantEcon</a></li><ul><li><a href="QuantEcon.html#Index-1">Index</a></li><li><a href="QuantEcon.html#Exported-1">Exported</a></li><li><a href="QuantEcon.html#Internal-1">Internal</a></li></ul></ul><h2><a class="nav-anchor" id="Index-1" href="#Index-1">Index</a></h2><ul><li><a href="QuantEcon.html#Base.e-Tuple{Real}"><code>Base.e</code></a></li><li><a href="QuantEcon.html#QuantEcon.ARMA"><code>QuantEcon.ARMA</code></a></li><li><a href="QuantEcon.html#QuantEcon.DPSolveResult"><code>QuantEcon.DPSolveResult</code></a></li><li><a href="QuantEcon.html#QuantEcon.DiscreteDP-Tuple{Array{T,NR},Array{T,NQ},Tbeta}"><code>QuantEcon.DiscreteDP</code></a></li><li><a href="QuantEcon.html#QuantEcon.DiscreteDP"><code>QuantEcon.DiscreteDP</code></a></li><li><a href="QuantEcon.html#QuantEcon.DiscreteDP-Tuple{AbstractArray{T,NR},AbstractArray{T,NQ},Tbeta,Array{Tind,1},Array{Tind,1}}"><code>QuantEcon.DiscreteDP</code></a></li><li><a href="QuantEcon.html#QuantEcon.DiscreteRV"><code>QuantEcon.DiscreteRV</code></a></li><li><a href="QuantEcon.html#QuantEcon.ECDF"><code>QuantEcon.ECDF</code></a></li><li><a href="QuantEcon.html#QuantEcon.LAE"><code>QuantEcon.LAE</code></a></li><li><a href="QuantEcon.html#QuantEcon.LQ"><code>QuantEcon.LQ</code></a></li><li><a href="QuantEcon.html#QuantEcon.LQ"><code>QuantEcon.LQ</code></a></li><li><a href="QuantEcon.html#QuantEcon.LSS"><code>QuantEcon.LSS</code></a></li><li><a href="QuantEcon.html#QuantEcon.LinInterp"><code>QuantEcon.LinInterp</code></a></li><li><a href="QuantEcon.html#QuantEcon.MPFI"><code>QuantEcon.MPFI</code></a></li><li><a href="QuantEcon.html#QuantEcon.MarkovChain-Tuple{QuantEcon.DiscreteDP,QuantEcon.DPSolveResult}"><code>QuantEcon.MarkovChain</code></a></li><li><a href="QuantEcon.html#QuantEcon.MarkovChain"><code>QuantEcon.MarkovChain</code></a></li><li><a href="QuantEcon.html#QuantEcon.PFI"><code>QuantEcon.PFI</code></a></li><li><a href="QuantEcon.html#QuantEcon.RBLQ"><code>QuantEcon.RBLQ</code></a></li><li><a href="QuantEcon.html#QuantEcon.VFI"><code>QuantEcon.VFI</code></a></li><li><a href="QuantEcon.html#Base.:*-Tuple{Array{T,3},Array{T,1}}"><code>Base.:*</code></a></li><li><a href="QuantEcon.html#Base.Random.rand-Tuple{QuantEcon.DiscreteRV,Int64}"><code>Base.Random.rand</code></a></li><li><a href="QuantEcon.html#Base.Random.rand-Tuple{QuantEcon.DiscreteRV}"><code>Base.Random.rand</code></a></li><li><a href="QuantEcon.html#LightGraphs.period-Tuple{QuantEcon.MarkovChain}"><code>LightGraphs.period</code></a></li><li><a href="QuantEcon.html#QuantEcon.F_to_K-Tuple{QuantEcon.RBLQ,Array{T,2}}"><code>QuantEcon.F_to_K</code></a></li><li><a href="QuantEcon.html#QuantEcon.K_to_F-Tuple{QuantEcon.RBLQ,Array{T,2}}"><code>QuantEcon.K_to_F</code></a></li><li><a href="QuantEcon.html#QuantEcon.RQ_sigma-Tuple{QuantEcon.DiscreteDP,QuantEcon.DPSolveResult}"><code>QuantEcon.RQ_sigma</code></a></li><li><a href="QuantEcon.html#QuantEcon.RQ_sigma-Tuple{QuantEcon.DiscreteDP{T,3,2,Tbeta,Tind},Array{T&lt;:Integer,N}}"><code>QuantEcon.RQ_sigma</code></a></li><li><a href="QuantEcon.html#QuantEcon._compute_sequence-Tuple{QuantEcon.LQ,Array{T,1},Any}"><code>QuantEcon._compute_sequence</code></a></li><li><a href="QuantEcon.html#QuantEcon._compute_sequence-Tuple{QuantEcon.LQ,T,Any}"><code>QuantEcon._compute_sequence</code></a></li><li><a href="QuantEcon.html#QuantEcon._generate_a_indptr!-Tuple{Int64,Array{T,1},Array{T,1}}"><code>QuantEcon._generate_a_indptr!</code></a></li><li><a href="QuantEcon.html#QuantEcon._has_sorted_sa_indices-Tuple{Array{T,1},Array{T,1}}"><code>QuantEcon._has_sorted_sa_indices</code></a></li><li><a href="QuantEcon.html#QuantEcon._random_stochastic_matrix-Tuple{Integer,Integer}"><code>QuantEcon._random_stochastic_matrix</code></a></li><li><a href="QuantEcon.html#QuantEcon._solve!-Tuple{QuantEcon.DiscreteDP,QuantEcon.DPSolveResult{QuantEcon.VFI,Tval&lt;:Real},Integer,Real,Integer}"><code>QuantEcon._solve!</code></a></li><li><a href="QuantEcon.html#QuantEcon._solve!-Tuple{QuantEcon.DiscreteDP,QuantEcon.DPSolveResult{QuantEcon.MPFI,Tval&lt;:Real},Integer,Real,Integer}"><code>QuantEcon._solve!</code></a></li><li><a href="QuantEcon.html#QuantEcon._solve!-Tuple{QuantEcon.DiscreteDP,QuantEcon.DPSolveResult{QuantEcon.PFI,Tval&lt;:Real},Integer,Real,Integer}"><code>QuantEcon._solve!</code></a></li><li><a href="QuantEcon.html#QuantEcon.ar_periodogram"><code>QuantEcon.ar_periodogram</code></a></li><li><a href="QuantEcon.html#QuantEcon.autocovariance-Tuple{QuantEcon.ARMA}"><code>QuantEcon.autocovariance</code></a></li><li><a href="QuantEcon.html#QuantEcon.b_operator-Tuple{QuantEcon.RBLQ,Array{T,2}}"><code>QuantEcon.b_operator</code></a></li><li><a href="QuantEcon.html#QuantEcon.bellman_operator-Tuple{QuantEcon.DiscreteDP,Array{T,1}}"><code>QuantEcon.bellman_operator</code></a></li><li><a href="QuantEcon.html#QuantEcon.bellman_operator!-Tuple{QuantEcon.DiscreteDP,Array{T,1},Array{T,1},Array{T,1}}"><code>QuantEcon.bellman_operator!</code></a></li><li><a href="QuantEcon.html#QuantEcon.bellman_operator!-Tuple{QuantEcon.DiscreteDP,Array{T&lt;:AbstractFloat,1},Array{T,1}}"><code>QuantEcon.bellman_operator!</code></a></li><li><a href="QuantEcon.html#QuantEcon.bellman_operator!-Tuple{QuantEcon.DiscreteDP,QuantEcon.DPSolveResult}"><code>QuantEcon.bellman_operator!</code></a></li><li><a href="QuantEcon.html#QuantEcon.bisect-Tuple{Function,T&lt;:AbstractFloat,T&lt;:AbstractFloat}"><code>QuantEcon.bisect</code></a></li><li><a href="QuantEcon.html#QuantEcon.brent-Tuple{Function,T&lt;:AbstractFloat,T&lt;:AbstractFloat}"><code>QuantEcon.brent</code></a></li><li><a href="QuantEcon.html#QuantEcon.brenth-Tuple{Function,T&lt;:AbstractFloat,T&lt;:AbstractFloat}"><code>QuantEcon.brenth</code></a></li><li><a href="QuantEcon.html#QuantEcon.ckron"><code>QuantEcon.ckron</code></a></li><li><a href="QuantEcon.html#QuantEcon.communication_classes-Tuple{QuantEcon.MarkovChain}"><code>QuantEcon.communication_classes</code></a></li><li><a href="QuantEcon.html#QuantEcon.compute_deterministic_entropy-Tuple{QuantEcon.RBLQ,Any,Any,Any}"><code>QuantEcon.compute_deterministic_entropy</code></a></li><li><a href="QuantEcon.html#QuantEcon.compute_fixed_point-Tuple{Function,TV}"><code>QuantEcon.compute_fixed_point</code></a></li><li><a href="QuantEcon.html#QuantEcon.compute_greedy-Tuple{QuantEcon.DiscreteDP,Array{TV&lt;:Real,1}}"><code>QuantEcon.compute_greedy</code></a></li><li><a href="QuantEcon.html#QuantEcon.compute_greedy!-Tuple{QuantEcon.DiscreteDP,QuantEcon.DPSolveResult}"><code>QuantEcon.compute_greedy!</code></a></li><li><a href="QuantEcon.html#QuantEcon.compute_sequence"><code>QuantEcon.compute_sequence</code></a></li><li><a href="QuantEcon.html#QuantEcon.d_operator-Tuple{QuantEcon.RBLQ,Array{T,2}}"><code>QuantEcon.d_operator</code></a></li><li><a href="QuantEcon.html#QuantEcon.divide_bracket"><code>QuantEcon.divide_bracket</code></a></li><li><a href="QuantEcon.html#QuantEcon.do_quad-Tuple{Function,Array,Array{T,1},Vararg{Any,N}}"><code>QuantEcon.do_quad</code></a></li><li><a href="QuantEcon.html#QuantEcon.estimate_mc_discrete-Tuple{Array{T,1},Array{T,1}}"><code>QuantEcon.estimate_mc_discrete</code></a></li><li><a href="QuantEcon.html#QuantEcon.evaluate_F-Tuple{QuantEcon.RBLQ,Array{T,2}}"><code>QuantEcon.evaluate_F</code></a></li><li><a href="QuantEcon.html#QuantEcon.evaluate_policy-Tuple{QuantEcon.DiscreteDP,QuantEcon.DPSolveResult}"><code>QuantEcon.evaluate_policy</code></a></li><li><a href="QuantEcon.html#QuantEcon.evaluate_policy-Tuple{QuantEcon.DiscreteDP,Array{T&lt;:Integer,1}}"><code>QuantEcon.evaluate_policy</code></a></li><li><a href="QuantEcon.html#QuantEcon.expand_bracket-Tuple{Function,T&lt;:Number,T&lt;:Number}"><code>QuantEcon.expand_bracket</code></a></li><li><a href="QuantEcon.html#QuantEcon.filtered_to_forecast!-Tuple{QuantEcon.Kalman}"><code>QuantEcon.filtered_to_forecast!</code></a></li><li><a href="QuantEcon.html#QuantEcon.fix"><code>QuantEcon.fix</code></a></li><li><a href="QuantEcon.html#QuantEcon.getZ-Tuple{Float64,Float64,Union{Array{T,1},Array{T,2}}}"><code>QuantEcon.getZ</code></a></li><li><a href="QuantEcon.html#QuantEcon.getZ-Tuple{Float64,Float64,Float64}"><code>QuantEcon.getZ</code></a></li><li><a href="QuantEcon.html#QuantEcon.getZ-Tuple{Array{T,2},Float64,Array{T,2}}"><code>QuantEcon.getZ</code></a></li><li><a href="QuantEcon.html#QuantEcon.gridmake"><code>QuantEcon.gridmake</code></a></li><li><a href="QuantEcon.html#QuantEcon.gridmake!-Tuple{Any,Vararg{Union{AbstractArray{T,1},AbstractArray{T,2}},N}}"><code>QuantEcon.gridmake!</code></a></li><li><a href="QuantEcon.html#QuantEcon.gth_solve-Tuple{Array{T&lt;:Real,2}}"><code>QuantEcon.gth_solve</code></a></li><li><a href="QuantEcon.html#QuantEcon.gth_solve!-Tuple{Array{T&lt;:Real,2}}"><code>QuantEcon.gth_solve!</code></a></li><li><a href="QuantEcon.html#QuantEcon.impulse_response-Tuple{QuantEcon.ARMA}"><code>QuantEcon.impulse_response</code></a></li><li><a href="QuantEcon.html#QuantEcon.interp-Tuple{AbstractArray{T,1},AbstractArray{T,1}}"><code>QuantEcon.interp</code></a></li><li><a href="QuantEcon.html#QuantEcon.is_aperiodic-Tuple{QuantEcon.MarkovChain}"><code>QuantEcon.is_aperiodic</code></a></li><li><a href="QuantEcon.html#QuantEcon.is_irreducible-Tuple{QuantEcon.MarkovChain}"><code>QuantEcon.is_irreducible</code></a></li><li><a href="QuantEcon.html#QuantEcon.lae_est-Tuple{QuantEcon.LAE,AbstractArray{T,N}}"><code>QuantEcon.lae_est</code></a></li><li><a href="QuantEcon.html#QuantEcon.m_quadratic_sum-Tuple{Array{T,2},Array{T,2}}"><code>QuantEcon.m_quadratic_sum</code></a></li><li><a href="QuantEcon.html#QuantEcon.moment_sequence-Tuple{QuantEcon.LSS}"><code>QuantEcon.moment_sequence</code></a></li><li><a href="QuantEcon.html#QuantEcon.n_states-Tuple{QuantEcon.MarkovChain}"><code>QuantEcon.n_states</code></a></li><li><a href="QuantEcon.html#QuantEcon.nnash-Tuple{Any,Any,Any,Any,Any,Any,Any,Any,Any,Any,Any,Any,Any}"><code>QuantEcon.nnash</code></a></li><li><a href="QuantEcon.html#QuantEcon.periodogram"><code>QuantEcon.periodogram</code></a></li><li><a href="QuantEcon.html#QuantEcon.prior_to_filtered!-Tuple{QuantEcon.Kalman,Any}"><code>QuantEcon.prior_to_filtered!</code></a></li><li><a href="QuantEcon.html#QuantEcon.qnwbeta-Tuple{Int64,Real,Real}"><code>QuantEcon.qnwbeta</code></a></li><li><a href="QuantEcon.html#QuantEcon.qnwcheb-Tuple{Int64,Real,Real}"><code>QuantEcon.qnwcheb</code></a></li><li><a href="QuantEcon.html#QuantEcon.qnwequi"><code>QuantEcon.qnwequi</code></a></li><li><a href="QuantEcon.html#QuantEcon.qnwgamma"><code>QuantEcon.qnwgamma</code></a></li><li><a href="QuantEcon.html#QuantEcon.qnwlege-Tuple{Int64,Real,Real}"><code>QuantEcon.qnwlege</code></a></li><li><a href="QuantEcon.html#QuantEcon.qnwlogn-Tuple{Any,Any,Any}"><code>QuantEcon.qnwlogn</code></a></li><li><a href="QuantEcon.html#QuantEcon.qnwnorm-Tuple{Int64}"><code>QuantEcon.qnwnorm</code></a></li><li><a href="QuantEcon.html#QuantEcon.qnwsimp-Tuple{Int64,Real,Real}"><code>QuantEcon.qnwsimp</code></a></li><li><a href="QuantEcon.html#QuantEcon.qnwtrap-Tuple{Int64,Real,Real}"><code>QuantEcon.qnwtrap</code></a></li><li><a href="QuantEcon.html#QuantEcon.qnwunif-Tuple{Any,Any,Any}"><code>QuantEcon.qnwunif</code></a></li><li><a href="QuantEcon.html#QuantEcon.quadrect"><code>QuantEcon.quadrect</code></a></li><li><a href="QuantEcon.html#QuantEcon.random_discrete_dp"><code>QuantEcon.random_discrete_dp</code></a></li><li><a href="QuantEcon.html#QuantEcon.random_markov_chain-Tuple{Integer,Integer}"><code>QuantEcon.random_markov_chain</code></a></li><li><a href="QuantEcon.html#QuantEcon.random_markov_chain-Tuple{Integer}"><code>QuantEcon.random_markov_chain</code></a></li><li><a href="QuantEcon.html#QuantEcon.random_probvec-Tuple{Integer,Integer}"><code>QuantEcon.random_probvec</code></a></li><li><a href="QuantEcon.html#QuantEcon.random_stochastic_matrix"><code>QuantEcon.random_stochastic_matrix</code></a></li><li><a href="QuantEcon.html#QuantEcon.recurrent_classes-Tuple{QuantEcon.MarkovChain}"><code>QuantEcon.recurrent_classes</code></a></li><li><a href="QuantEcon.html#QuantEcon.replicate"><code>QuantEcon.replicate</code></a></li><li><a href="QuantEcon.html#QuantEcon.ridder-Tuple{Function,T&lt;:AbstractFloat,T&lt;:AbstractFloat}"><code>QuantEcon.ridder</code></a></li><li><a href="QuantEcon.html#QuantEcon.robust_rule-Tuple{QuantEcon.RBLQ}"><code>QuantEcon.robust_rule</code></a></li><li><a href="QuantEcon.html#QuantEcon.robust_rule_simple"><code>QuantEcon.robust_rule_simple</code></a></li><li><a href="QuantEcon.html#QuantEcon.rouwenhorst"><code>QuantEcon.rouwenhorst</code></a></li><li><a href="QuantEcon.html#QuantEcon.s_wise_max-Tuple{AbstractArray{T,2}}"><code>QuantEcon.s_wise_max</code></a></li><li><a href="QuantEcon.html#QuantEcon.s_wise_max!-Tuple{Array{T,1},Array{T,1},Array{T,1},Array{T,1},Array{T,1}}"><code>QuantEcon.s_wise_max!</code></a></li><li><a href="QuantEcon.html#QuantEcon.s_wise_max!-Tuple{AbstractArray{T,2},Array{T,1},Array{T,1}}"><code>QuantEcon.s_wise_max!</code></a></li><li><a href="QuantEcon.html#QuantEcon.s_wise_max!-Tuple{Array{T,1},Array{T,1},Array{T,1},Array{T,1}}"><code>QuantEcon.s_wise_max!</code></a></li><li><a href="QuantEcon.html#QuantEcon.s_wise_max!-Tuple{AbstractArray{T,2},Array{T,1}}"><code>QuantEcon.s_wise_max!</code></a></li><li><a href="QuantEcon.html#QuantEcon.simulate-Tuple{QuantEcon.MarkovChain,Int64}"><code>QuantEcon.simulate</code></a></li><li><a href="QuantEcon.html#QuantEcon.simulate!-Tuple{Union{AbstractArray{T,1},AbstractArray{T,2}},QuantEcon.MarkovChain}"><code>QuantEcon.simulate!</code></a></li><li><a href="QuantEcon.html#QuantEcon.simulate_indices-Tuple{QuantEcon.MarkovChain,Int64}"><code>QuantEcon.simulate_indices</code></a></li><li><a href="QuantEcon.html#QuantEcon.simulate_indices!-Tuple{Union{AbstractArray{T&lt;:Integer,1},AbstractArray{T&lt;:Integer,2}},QuantEcon.MarkovChain}"><code>QuantEcon.simulate_indices!</code></a></li><li><a href="QuantEcon.html#QuantEcon.simulation-Tuple{QuantEcon.ARMA}"><code>QuantEcon.simulation</code></a></li><li><a href="QuantEcon.html#QuantEcon.smooth"><code>QuantEcon.smooth</code></a></li><li><a href="QuantEcon.html#QuantEcon.smooth-Tuple{Array}"><code>QuantEcon.smooth</code></a></li><li><a href="QuantEcon.html#QuantEcon.solve"><code>QuantEcon.solve</code></a></li><li><a href="QuantEcon.html#QuantEcon.solve_discrete_lyapunov"><code>QuantEcon.solve_discrete_lyapunov</code></a></li><li><a href="QuantEcon.html#QuantEcon.solve_discrete_riccati"><code>QuantEcon.solve_discrete_riccati</code></a></li><li><a href="QuantEcon.html#QuantEcon.spectral_density-Tuple{QuantEcon.ARMA}"><code>QuantEcon.spectral_density</code></a></li><li><a href="QuantEcon.html#QuantEcon.stationary_distributions-Tuple{QuantEcon.LSS}"><code>QuantEcon.stationary_distributions</code></a></li><li><a href="QuantEcon.html#QuantEcon.stationary_distributions"><code>QuantEcon.stationary_distributions</code></a></li><li><a href="QuantEcon.html#QuantEcon.stationary_values-Tuple{QuantEcon.LQ}"><code>QuantEcon.stationary_values</code></a></li><li><a href="QuantEcon.html#QuantEcon.stationary_values!-Tuple{QuantEcon.LQ}"><code>QuantEcon.stationary_values!</code></a></li><li><a href="QuantEcon.html#QuantEcon.tauchen"><code>QuantEcon.tauchen</code></a></li><li><a href="QuantEcon.html#QuantEcon.todense-Tuple{Type,Array}"><code>QuantEcon.todense</code></a></li><li><a href="QuantEcon.html#QuantEcon.todense-Tuple{Type,SparseMatrixCSC}"><code>QuantEcon.todense</code></a></li><li><a href="QuantEcon.html#QuantEcon.update!-Tuple{QuantEcon.Kalman,Any}"><code>QuantEcon.update!</code></a></li><li><a href="QuantEcon.html#QuantEcon.update_values!-Tuple{QuantEcon.LQ}"><code>QuantEcon.update_values!</code></a></li><li><a href="QuantEcon.html#QuantEcon.var_quadratic_sum-Tuple{Union{Array{T,N},T},Union{Array{T,N},T},Union{Array{T,N},T},Real,Union{Array{T,N},T}}"><code>QuantEcon.var_quadratic_sum</code></a></li></ul><h2><a class="nav-anchor" id="Exported-1" href="#Exported-1">Exported</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantEcon.ARMA" href="#QuantEcon.ARMA"><code>QuantEcon.ARMA</code></a> — <span class="docstring-category">Type</span>.</div><div><p>Represents a scalar ARMA(p, q) process</p><p>If <span>$\phi$</span> and <span>$\theta$</span> are scalars, then the model is understood to be</p><div>\[    X_t = \phi X_{t-1} + \epsilon_t + \theta \epsilon_{t-1}\]</div><p>where <span>$\epsilon_t$</span> is a white noise process with standard deviation sigma.</p><p>If <span>$\phi$</span> and <span>$\theta$</span> are arrays or sequences, then the interpretation is the ARMA(p, q) model</p><div>\[    X_t = \phi_1 X_{t-1} + ... + \phi_p X_{t-p} +
    \epsilon_t + \theta_1 \epsilon_{t-1} + \ldots  +
    \theta_q \epsilon_{t-q}\]</div><p>where</p><ul><li><p><span>$\phi = (\phi_1, \phi_2, \ldots , \phi_p)$</span></p></li><li><p><span>$\theta = (\theta_1, \theta_2, \ldots , \theta_q)$</span></p></li><li><p><span>$\sigma$</span> is a scalar, the standard deviation of the white noise</p></li></ul><p><strong>Fields</strong></p><ul><li><p><code>phi::Vector</code> : AR parameters <span>$\phi_1, \ldots, \phi_p$</span></p></li><li><p><code>theta::Vector</code> : MA parameters <span>$\theta_1, \ldots, \theta_q$</span></p></li><li><p><code>p::Integer</code> : Number of AR coefficients</p></li><li><p><code>q::Integer</code> : Number of MA coefficients</p></li><li><p><code>sigma::Real</code> : Standard deviation of white noise</p></li><li><p><code>ma_poly::Vector</code> : MA polynomial –- filtering representatoin</p></li><li><p><code>ar_poly::Vector</code> : AR polynomial –- filtering representation</p></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia">using QuantEcon
phi = 0.5
theta = [0.0, -0.8]
sigma = 1.0
lp = ARMA(phi, theta, sigma)
require(joinpath(dirname(@__FILE__),&quot;..&quot;, &quot;examples&quot;, &quot;arma_plots.jl&quot;))
quad_plot(lp)</code></pre></div><a class="source-link" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/tree/f744b5bd0dbe0f65cf0ff32bc5a744948435e4ec/src/arma.jl#L18">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantEcon.DiscreteDP" href="#QuantEcon.DiscreteDP"><code>QuantEcon.DiscreteDP</code></a> — <span class="docstring-category">Type</span>.</div><div><p>DiscreteDP type for specifying paramters for discrete dynamic programming model</p><p><strong>Parameters</strong></p><ul><li><p><code>R::Array{T,NR}</code> : Reward Array</p></li><li><p><code>Q::Array{T,NQ}</code> : Transition Probability Array</p></li><li><p><code>beta::Float64</code>  : Discount Factor</p></li><li><p><code>a_indices::Nullable{Vector{Tind}}</code>: Action Indices. Null unless using SA formulation</p></li><li><p><code>a_indptr::Nullable{Vector{Tind}}</code>: Action Index Pointers. Null unless using SA formulation</p></li></ul><p><strong>Returns</strong></p><ul><li><p><code>ddp::DiscreteDP</code> : DiscreteDP object</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/tree/f744b5bd0dbe0f65cf0ff32bc5a744948435e4ec/src/markov/ddp.jl#L31-L48">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantEcon.DiscreteDP-Tuple{AbstractArray{T,NR},AbstractArray{T,NQ},Tbeta,Array{Tind,1},Array{Tind,1}}" href="#QuantEcon.DiscreteDP-Tuple{AbstractArray{T,NR},AbstractArray{T,NQ},Tbeta,Array{Tind,1},Array{Tind,1}}"><code>QuantEcon.DiscreteDP</code></a> — <span class="docstring-category">Method</span>.</div><div><p>DiscreteDP type for specifying parameters for discrete dynamic programming model State-Action Pair Formulation</p><p><strong>Parameters</strong></p><ul><li><p><code>R::Array{T,NR}</code> : Reward Array</p></li><li><p><code>Q::Array{T,NQ}</code> : Transition Probability Array</p></li><li><p><code>beta::Float64</code>  : Discount Factor</p></li><li><p><code>s_indices::Nullable{Vector{Tind}}</code>: State Indices. Null unless using SA formulation</p></li><li><p><code>a_indices::Nullable{Vector{Tind}}</code>: Action Indices. Null unless using SA formulation</p></li><li><p><code>a_indptr::Nullable{Vector{Tind}}</code>: Action Index Pointers. Null unless using SA formulation</p></li></ul><p><strong>Returns</strong></p><ul><li><p><code>ddp::DiscreteDP</code> : Constructor for DiscreteDP object</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/tree/f744b5bd0dbe0f65cf0ff32bc5a744948435e4ec/src/markov/ddp.jl#L175-L195">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantEcon.DiscreteDP-Tuple{Array{T,NR},Array{T,NQ},Tbeta}" href="#QuantEcon.DiscreteDP-Tuple{Array{T,NR},Array{T,NQ},Tbeta}"><code>QuantEcon.DiscreteDP</code></a> — <span class="docstring-category">Method</span>.</div><div><p>DiscreteDP type for specifying parameters for discrete dynamic programming model Dense Matrix Formulation</p><p><strong>Parameters</strong></p><ul><li><p><code>R::Array{T,NR}</code> : Reward Array</p></li><li><p><code>Q::Array{T,NQ}</code> : Transition Probability Array</p></li><li><p><code>beta::Float64</code>  : Discount Factor</p></li></ul><p><strong>Returns</strong></p><ul><li><p><code>ddp::DiscreteDP</code> : Constructor for DiscreteDP object</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/tree/f744b5bd0dbe0f65cf0ff32bc5a744948435e4ec/src/markov/ddp.jl#L158-L171">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantEcon.DiscreteRV" href="#QuantEcon.DiscreteRV"><code>QuantEcon.DiscreteRV</code></a> — <span class="docstring-category">Type</span>.</div><div><p>Generates an array of draws from a discrete random variable with vector of probabilities given by <code>q</code>.</p><p><strong>Fields</strong></p><ul><li><p><code>q::AbstractVector</code>: A vector of non-negative probabilities that sum to 1</p></li><li><p><code>Q::AbstractVector</code>: The cumulative sum of <code>q</code></p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/tree/f744b5bd0dbe0f65cf0ff32bc5a744948435e4ec/src/discrete_rv.jl#L22-L30">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantEcon.ECDF" href="#QuantEcon.ECDF"><code>QuantEcon.ECDF</code></a> — <span class="docstring-category">Type</span>.</div><div><p>One-dimensional empirical distribution function given a vector of observations.</p><p><strong>Fields</strong></p><ul><li><p><code>observations::Vector</code>: The vector of observations</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/tree/f744b5bd0dbe0f65cf0ff32bc5a744948435e4ec/src/ecdf.jl#L12-L19">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantEcon.LAE" href="#QuantEcon.LAE"><code>QuantEcon.LAE</code></a> — <span class="docstring-category">Type</span>.</div><div><p>A look ahead estimator associated with a given stochastic kernel <code>p</code> and a vector of observations <code>X</code>.</p><p><strong>Fields</strong></p><ul><li><p><code>p::Function</code>: The stochastic kernel. Signature is <code>p(x, y)</code> and it should be vectorized in both inputs</p></li><li><p><code>X::Matrix</code>: A vector containing observations. Note that this can be passed as any kind of <code>AbstractArray</code> and will be coerced into an <code>n x 1</code> vector.</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/tree/f744b5bd0dbe0f65cf0ff32bc5a744948435e4ec/src/lae.jl#L22-L33">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantEcon.LQ" href="#QuantEcon.LQ"><code>QuantEcon.LQ</code></a> — <span class="docstring-category">Type</span>.</div><div><p>Main constructor for LQ type</p><p>Specifies default argumets for all fields not part of the payoff function or transition equation.</p><p><strong>Arguments</strong></p><ul><li><p><code>Q::ScalarOrArray</code> : <code>k x k</code> payoff coefficient for control variable u. Must be symmetric and nonnegative definite</p></li><li><p><code>R::ScalarOrArray</code> : <code>n x n</code> payoff coefficient matrix for state variable x. Must be symmetric and nonnegative definite</p></li><li><p><code>A::ScalarOrArray</code> : <code>n x n</code> coefficient on state in state transition</p></li><li><p><code>B::ScalarOrArray</code> : <code>n x k</code> coefficient on control in state transition</p></li><li><p><code>;C::ScalarOrArray{zeros(size(R}(1)))</code> : <code>n x j</code> coefficient on random shock in state transition</p></li><li><p><code>;N::ScalarOrArray{zeros(size(B,1)}(size(A, 2)))</code> : <code>k x n</code> cross product in payoff equation</p></li><li><p><code>;bet::Real(1.0)</code> : Discount factor in <code>[0, 1]</code></p></li><li><p><code>capT::Union{Int, Void}(Void)</code> : Terminal period in finite horizon problem</p></li><li><p><code>rf::ScalarOrArray{fill(NaN}(size(R)...))</code> : <code>n x n</code> terminal payoff in finite horizon problem. Must be symmetric and nonnegative definite.</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/tree/f744b5bd0dbe0f65cf0ff32bc5a744948435e4ec/src/lqcontrol.jl#L92-L116">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantEcon.LQ" href="#QuantEcon.LQ"><code>QuantEcon.LQ</code></a> — <span class="docstring-category">Type</span>.</div><div><p>Linear quadratic optimal control of either infinite or finite horizon</p><p>The infinite horizon problem can be written</p><div>\[\min \mathbb{E} \sum_{t=0}^{\infty} \beta^t r(x_t, u_t)\]</div><p>with</p><div>\[r(x_t, u_t) := x_t&#39; R x_t + u_t&#39; Q u_t + 2 u_t&#39; N x_t\]</div><p>The finite horizon form is</p><div>\[\min \mathbb{E} \sum_{t=0}^{T-1} \beta^t r(x_t, u_t) + \beta^T x_T&#39; R_f x_T\]</div><p>Both are minimized subject to the law of motion</p><div>\[x_{t+1} = A x_t + B u_t + C w_{t+1}\]</div><p>Here <span>$x$</span> is n x 1, <span>$u$</span> is k x 1, <span>$w$</span> is j x 1 and the matrices are conformable for these dimensions.  The sequence <span>${w_t}$</span> is assumed to be white noise, with zero mean and <span>$\mathbb{E} w_t w_t&#39; = I$</span>, the j x j identity.</p><p>For this model, the time <span>$t$</span> value (i.e., cost-to-go) function <span>$V_t$</span> takes the form</p><div>\[x&#39; P_T x + d_T\]</div><p>and the optimal policy is of the form <span>$u_T = -F_T x_T$</span>.  In the infinite horizon case, <span>$V, P, d$</span> and <span>$F$</span> are all stationary.</p><p><strong>Fields</strong></p><ul><li><p><code>Q::ScalarOrArray</code> : <code>k x k</code> payoff coefficient for control variable u. Must be symmetric and nonnegative definite</p></li><li><p><code>R::ScalarOrArray</code> : <code>n x n</code> payoff coefficient matrix for state variable x. Must be symmetric and nonnegative definite</p></li><li><p><code>A::ScalarOrArray</code> : <code>n x n</code> coefficient on state in state transition</p></li><li><p><code>B::ScalarOrArray</code> : <code>n x k</code> coefficient on control in state transition</p></li><li><p><code>C::ScalarOrArray</code> : <code>n x j</code> coefficient on random shock in state transition</p></li><li><p><code>N::ScalarOrArray</code> : <code>k x n</code> cross product in payoff equation</p></li><li><p><code>bet::Real</code> : Discount factor in <code>[0, 1]</code></p></li><li><p><code>capT::Union{Int, Void}</code> : Terminal period in finite horizon problem</p></li><li><p><code>rf::ScalarOrArray</code> : <code>n x n</code> terminal payoff in finite horizon problem. Must be symmetric and nonnegative definite</p></li><li><p><code>P::ScalarOrArray</code> : <code>n x n</code> matrix in value function representation <span>$V(x) = x&#39;Px + d$</span></p></li><li><p><code>d::Real</code> : Constant in value function representation</p></li><li><p><code>F::ScalarOrArray</code> : Policy rule that specifies optimal control in each period</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/tree/f744b5bd0dbe0f65cf0ff32bc5a744948435e4ec/src/lqcontrol.jl#L17">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantEcon.LSS" href="#QuantEcon.LSS"><code>QuantEcon.LSS</code></a> — <span class="docstring-category">Type</span>.</div><div><p>A type that describes the Gaussian Linear State Space Model of the form:</p><div>\[    x_{t+1} = A x_t + C w_{t+1} \\
    
    y_t = G x_t + H v_t\]</div><p>where <span>${w_t}$</span> and <span>${v_t}$</span> are independent and standard normal with dimensions <code>k</code> and <code>l</code> respectively.  The initial conditions are <span>$\mu_0$</span> and <span>$\Sigma_0$</span> for <span>$x_0 \sim N(\mu_0, \Sigma_0)$</span>. When <span>$\Sigma_0=0$</span>, the draw of <span>$x_0$</span> is exactly <span>$\mu_0$</span>.</p><p><strong>Fields</strong></p><ul><li><p><code>A::Matrix</code> Part of the state transition equation.  It should be <code>n x n</code></p></li><li><p><code>C::Matrix</code> Part of the state transition equation.  It should be <code>n x m</code></p></li><li><p><code>G::Matrix</code> Part of the observation equation.  It should be <code>k x n</code></p></li><li><p><code>H::Matrix</code> Part of the observation equation.  It should be <code>k x l</code></p></li><li><p><code>k::Int</code> Dimension</p></li><li><p><code>n::Int</code> Dimension</p></li><li><p><code>m::Int</code> Dimension</p></li><li><p><code>l::Int</code> Dimension</p></li><li><p><code>mu_0::Vector</code> This is the mean of initial draw and is of length <code>n</code></p></li><li><p><code>Sigma_0::Matrix</code> This is the variance of the initial draw and is <code>n x n</code> and                   also should be positive definite and symmetric</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/tree/f744b5bd0dbe0f65cf0ff32bc5a744948435e4ec/src/lss.jl#L24">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantEcon.LinInterp" href="#QuantEcon.LinInterp"><code>QuantEcon.LinInterp</code></a> — <span class="docstring-category">Type</span>.</div><div><p>Linear interpolation in one dimension</p><p><strong>Fields</strong></p><ul><li><p><code>breaks::AbstractVector</code> : A sorted array of grid points on which to interpolate</p></li><li><p><code>vals::AbstractVector</code> : The function values associated with each of the grid points</p></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia">breaks = cumsum(0.1 .* rand(20))
vals = 0.1 .* sin.(breaks)
li = LinInterp(breaks, vals)

# do interpolation via `call` method on a LinInterp object
li(0.2)

# use broadcasting to evaluate at multiple points
li.([0.1, 0.2, 0.3])</code></pre></div><a class="source-link" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/tree/f744b5bd0dbe0f65cf0ff32bc5a744948435e4ec/src/interp.jl#L1-L24">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantEcon.MPFI" href="#QuantEcon.MPFI"><code>QuantEcon.MPFI</code></a> — <span class="docstring-category">Type</span>.</div><div><p>This refers to the Modified Policy Iteration solution algorithm.</p><p><strong>References</strong></p><p>https://lectures.quantecon.org/py/discrete_dp.html</p></div><a class="source-link" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/tree/f744b5bd0dbe0f65cf0ff32bc5a744948435e4ec/src/markov/ddp.jl#L241-L249">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantEcon.MarkovChain" href="#QuantEcon.MarkovChain"><code>QuantEcon.MarkovChain</code></a> — <span class="docstring-category">Type</span>.</div><div><p>Finite-state discrete-time Markov chain.</p><p>Methods are available that provide useful information such as the stationary distributions, and communication and recurrent classes, and allow simulation of state transitions.</p><p><strong>Fields</strong></p><ul><li><p><code>p::AbstractMatrix</code> : The transition matrix. Must be square, all elements must be nonnegative, and all rows must sum to unity.</p></li><li><p><code>state_values::AbstractVector</code> : Vector containing the values associated with the states.</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/tree/f744b5bd0dbe0f65cf0ff32bc5a744948435e4ec/src/markov/mc_tools.jl#L19-L30">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantEcon.MarkovChain-Tuple{QuantEcon.DiscreteDP,QuantEcon.DPSolveResult}" href="#QuantEcon.MarkovChain-Tuple{QuantEcon.DiscreteDP,QuantEcon.DPSolveResult}"><code>QuantEcon.MarkovChain</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Returns the controlled Markov chain for a given policy <code>sigma</code>.</p><p><strong>Parameters</strong></p><ul><li><p><code>ddp::DiscreteDP</code> : Object that contains the model parameters</p></li><li><p><code>ddpr::DPSolveResult</code> : Object that contains result variables</p></li></ul><p><strong>Returns</strong></p><p>mc : MarkovChain      Controlled Markov chain.</p></div><a class="source-link" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/tree/f744b5bd0dbe0f65cf0ff32bc5a744948435e4ec/src/markov/ddp.jl#L503-L515">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantEcon.PFI" href="#QuantEcon.PFI"><code>QuantEcon.PFI</code></a> — <span class="docstring-category">Type</span>.</div><div><p>This refers to the Policy Iteration solution algorithm.</p><p><strong>References</strong></p><p>https://lectures.quantecon.org/py/discrete_dp.html</p></div><a class="source-link" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/tree/f744b5bd0dbe0f65cf0ff32bc5a744948435e4ec/src/markov/ddp.jl#L230-L238">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantEcon.RBLQ" href="#QuantEcon.RBLQ"><code>QuantEcon.RBLQ</code></a> — <span class="docstring-category">Type</span>.</div><div><p>Represents infinite horizon robust LQ control problems of the form</p><div>\[    \min_{u_t} \sum_t \beta^t {x_t&#39; R x_t + u_t&#39; Q u_t }\]</div><p>subject to</p><div>\[    x_{t+1} = A x_t + B u_t + C w_{t+1}\]</div><p>and with model misspecification parameter <span>$\theta$</span>.</p><p><strong>Fields</strong></p><ul><li><p><code>Q::Matrix{Float64}</code> :  The cost(payoff) matrix for the controls. See above for more. <span>$Q$</span> should be <code>k x k</code> and symmetric and positive definite</p></li><li><p><code>R::Matrix{Float64}</code> :  The cost(payoff) matrix for the state. See above for more. <span>$R$</span> should be <code>n x n</code> and symmetric and non-negative definite</p></li><li><p><code>A::Matrix{Float64}</code> :  The matrix that corresponds with the state in the state space system. <span>$A$</span> should be <code>n x n</code></p></li><li><p><code>B::Matrix{Float64}</code> :  The matrix that corresponds with the control in the state space system.  <span>$B$</span> should be <code>n x k</code></p></li><li><p><code>C::Matrix{Float64}</code> :  The matrix that corresponds with the random process in the state space system. <span>$C$</span> should be <code>n x j</code></p></li><li><p><code>beta::Real</code> : The discount factor in the robust control problem</p></li><li><p><code>theta::Real</code> The robustness factor in the robust control problem</p></li><li><p><code>k, n, j::Int</code> : Dimensions of input matrices</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/tree/f744b5bd0dbe0f65cf0ff32bc5a744948435e4ec/src/robustlq.jl#L15">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantEcon.VFI" href="#QuantEcon.VFI"><code>QuantEcon.VFI</code></a> — <span class="docstring-category">Type</span>.</div><div><p>This refers to the Value Iteration solution algorithm.</p><p><strong>References</strong></p><p>https://lectures.quantecon.org/py/discrete_dp.html</p></div><a class="source-link" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/tree/f744b5bd0dbe0f65cf0ff32bc5a744948435e4ec/src/markov/ddp.jl#L219-L227">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.period-Tuple{QuantEcon.MarkovChain}" href="#LightGraphs.period-Tuple{QuantEcon.MarkovChain}"><code>LightGraphs.period</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Return the period of the Markov chain <code>mc</code>.</p><p><strong>Arguments</strong></p><ul><li><p><code>mc::MarkovChain</code> : MarkovChain instance.</p></li></ul><p><strong>Returns</strong></p><ul><li><p><code>::Int</code> : Period of <code>mc</code>.</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/tree/f744b5bd0dbe0f65cf0ff32bc5a744948435e4ec/src/markov/mc_tools.jl#L210-L221">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantEcon.F_to_K-Tuple{QuantEcon.RBLQ,Array{T,2}}" href="#QuantEcon.F_to_K-Tuple{QuantEcon.RBLQ,Array{T,2}}"><code>QuantEcon.F_to_K</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Compute agent 2&#39;s best cost-minimizing response <span>$K$</span>, given <span>$F$</span>.</p><p><strong>Arguments</strong></p><ul><li><p><code>rlq::RBLQ</code>: Instance of <code>RBLQ</code> type</p></li><li><p><code>F::Matrix{Float64}</code>: A <code>k x n</code> array representing agent 1&#39;s policy</p></li></ul><p><strong>Returns</strong></p><ul><li><p><code>K::Matrix{Float64}</code> : Agent&#39;s best cost minimizing response corresponding to <span>$F$</span></p></li><li><p><code>P::Matrix{Float64}</code> : The value function corresponding to <span>$F$</span></p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/tree/f744b5bd0dbe0f65cf0ff32bc5a744948435e4ec/src/robustlq.jl#L231">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantEcon.K_to_F-Tuple{QuantEcon.RBLQ,Array{T,2}}" href="#QuantEcon.K_to_F-Tuple{QuantEcon.RBLQ,Array{T,2}}"><code>QuantEcon.K_to_F</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Compute agent 1&#39;s best cost-minimizing response <span>$K$</span>, given <span>$F$</span>.</p><p><strong>Arguments</strong></p><ul><li><p><code>rlq::RBLQ</code>: Instance of <code>RBLQ</code> type</p></li><li><p><code>K::Matrix{Float64}</code>: A <code>k x n</code> array representing the worst case matrix</p></li></ul><p><strong>Returns</strong></p><ul><li><p><code>F::Matrix{Float64}</code> : Agent&#39;s best cost minimizing response corresponding to <span>$K$</span></p></li><li><p><code>P::Matrix{Float64}</code> : The value function corresponding to <span>$K$</span></p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/tree/f744b5bd0dbe0f65cf0ff32bc5a744948435e4ec/src/robustlq.jl#L262">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantEcon.RQ_sigma-Tuple{QuantEcon.DiscreteDP,QuantEcon.DPSolveResult}" href="#QuantEcon.RQ_sigma-Tuple{QuantEcon.DiscreteDP,QuantEcon.DPSolveResult}"><code>QuantEcon.RQ_sigma</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Method of <code>RQ_sigma</code> that extracts sigma from a <code>DPSolveResult</code></p><p>See other docstring for details</p></div><a class="source-link" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/tree/f744b5bd0dbe0f65cf0ff32bc5a744948435e4ec/src/markov/ddp.jl#L519-L523">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantEcon.RQ_sigma-Tuple{QuantEcon.DiscreteDP{T,3,2,Tbeta,Tind},Array{T&lt;:Integer,N}}" href="#QuantEcon.RQ_sigma-Tuple{QuantEcon.DiscreteDP{T,3,2,Tbeta,Tind},Array{T&lt;:Integer,N}}"><code>QuantEcon.RQ_sigma</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Given a policy <code>sigma</code>, return the reward vector <code>R_sigma</code> and the transition probability matrix <code>Q_sigma</code>.</p><p><strong>Parameters</strong></p><ul><li><p><code>ddp::DiscreteDP</code> : Object that contains the model parameters</p></li><li><p><code>sigma::Vector{Int}</code>: policy rule vector</p></li></ul><p><strong>Returns</strong></p><ul><li><p><code>R_sigma::Array{Float64}</code>: Reward vector for <code>sigma</code>, of length <code>n</code>.</p></li><li><p><code>Q_sigma::Array{Float64}</code>: Transition probability matrix for <code>sigma</code>, of shape <code>(n, n)</code>.</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/tree/f744b5bd0dbe0f65cf0ff32bc5a744948435e4ec/src/markov/ddp.jl#L526-L542">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantEcon.ar_periodogram" href="#QuantEcon.ar_periodogram"><code>QuantEcon.ar_periodogram</code></a> — <span class="docstring-category">Function</span>.</div><div><p>Compute periodogram from data <code>x</code>, using prewhitening, smoothing and recoloring. The data is fitted to an AR(1) model for prewhitening, and the residuals are used to compute a first-pass periodogram with smoothing.  The fitted coefficients are then used for recoloring.</p><p><strong>Arguments</strong></p><ul><li><p><code>x::Array</code>: An array containing the data to smooth</p></li><li><p><code>window_len::Int(7)</code>: An odd integer giving the length of the window</p></li><li><p><code>window::AbstractString(&quot;hanning&quot;)</code>: A string giving the window type. Possible values are <code>flat</code>, <code>hanning</code>, <code>hamming</code>, <code>bartlett</code>, or <code>blackman</code></p></li></ul><p><strong>Returns</strong></p><ul><li><p><code>w::Array{Float64}</code>: Fourier frequencies at which the periodogram is evaluated</p></li><li><p><code>I_w::Array{Float64}</code>: The periodogram at frequences <code>w</code></p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/tree/f744b5bd0dbe0f65cf0ff32bc5a744948435e4ec/src/estspec.jl#L119-L137">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantEcon.autocovariance-Tuple{QuantEcon.ARMA}" href="#QuantEcon.autocovariance-Tuple{QuantEcon.ARMA}"><code>QuantEcon.autocovariance</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Compute the autocovariance function from the ARMA parameters over the integers range(<code>num_autocov</code>) using the spectral density and the inverse Fourier transform.</p><p><strong>Arguments</strong></p><ul><li><p><code>arma::ARMA</code>: Instance of <code>ARMA</code> type</p></li><li><p><code>;num_autocov::Integer(16)</code> : The number of autocovariances to calculate</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/tree/f744b5bd0dbe0f65cf0ff32bc5a744948435e4ec/src/arma.jl#L132-L142">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantEcon.b_operator-Tuple{QuantEcon.RBLQ,Array{T,2}}" href="#QuantEcon.b_operator-Tuple{QuantEcon.RBLQ,Array{T,2}}"><code>QuantEcon.b_operator</code></a> — <span class="docstring-category">Method</span>.</div><div><p>The <span>$D$</span> operator, mapping <span>$P$</span> into</p><div>\[    B(P) := R - \beta^2 A&#39;PB(Q + \beta B&#39;PB)^{-1}B&#39;PA + \beta A&#39;PA\]</div><p>and also returning</p><div>\[    F := (Q + \beta B&#39;PB)^{-1} \beta B&#39;PA\]</div><p><strong>Arguments</strong></p><ul><li><p><code>rlq::RBLQ</code>: Instance of <code>RBLQ</code> type</p></li><li><p><code>P::Matrix{Float64}</code> : size is <code>n x n</code></p></li></ul><p><strong>Returns</strong></p><ul><li><p><code>F::Matrix{Float64}</code> : The <span>$F$</span> matrix as defined above</p></li><li><p><code>new_p::Matrix{Float64}</code> : The matrix <span>$P$</span> after applying the <span>$B$</span> operator</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/tree/f744b5bd0dbe0f65cf0ff32bc5a744948435e4ec/src/robustlq.jl#L95">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantEcon.bellman_operator!-Tuple{QuantEcon.DiscreteDP,Array{T,1},Array{T,1},Array{T,1}}" href="#QuantEcon.bellman_operator!-Tuple{QuantEcon.DiscreteDP,Array{T,1},Array{T,1},Array{T,1}}"><code>QuantEcon.bellman_operator!</code></a> — <span class="docstring-category">Method</span>.</div><div><p>The Bellman operator, which computes and returns the updated value function <span>$Tv$</span> for a value function <span>$v$</span>.</p><p><strong>Parameters</strong></p><ul><li><p><code>ddp::DiscreteDP</code> : Object that contains the model parameters</p></li><li><p><code>v::Vector{T&lt;:AbstractFloat}</code>: The current guess of the value function</p></li><li><p><code>Tv::Vector{T&lt;:AbstractFloat}</code>: A buffer array to hold the updated value function. Initial value not used and will be overwritten</p></li><li><p><code>sigma::Vector</code>: A buffer array to hold the policy function. Initial values not used and will be overwritten</p></li></ul><p><strong>Returns</strong></p><ul><li><p><code>Tv::Vector</code> : Updated value function vector</p></li><li><p><code>sigma::Vector</code> : Updated policiy function vector</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/tree/f744b5bd0dbe0f65cf0ff32bc5a744948435e4ec/src/markov/ddp.jl#L299">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantEcon.bellman_operator!-Tuple{QuantEcon.DiscreteDP,Array{T&lt;:AbstractFloat,1},Array{T,1}}" href="#QuantEcon.bellman_operator!-Tuple{QuantEcon.DiscreteDP,Array{T&lt;:AbstractFloat,1},Array{T,1}}"><code>QuantEcon.bellman_operator!</code></a> — <span class="docstring-category">Method</span>.</div><div><p>The Bellman operator, which computes and returns the updated value function <span>$Tv$</span> for a given value function <span>$v$</span>.</p><p>This function will fill the input <code>v</code> with <code>Tv</code> and the input <code>sigma</code> with the corresponding policy rule.</p><p><strong>Parameters</strong></p><ul><li><p><code>ddp::DiscreteDP</code>: The ddp model</p></li><li><p><code>v::Vector{T&lt;:AbstractFloat}</code>: The current guess of the value function. This array will be overwritten</p></li><li><p><code>sigma::Vector</code>: A buffer array to hold the policy function. Initial values not used and will be overwritten</p></li></ul><p><strong>Returns</strong></p><ul><li><p><code>Tv::Vector</code>: Updated value function vector</p></li><li><p><code>sigma::Vector{T&lt;:Integer}</code>: Policy rule</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/tree/f744b5bd0dbe0f65cf0ff32bc5a744948435e4ec/src/markov/ddp.jl#L334-L353">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantEcon.bellman_operator!-Tuple{QuantEcon.DiscreteDP,QuantEcon.DPSolveResult}" href="#QuantEcon.bellman_operator!-Tuple{QuantEcon.DiscreteDP,QuantEcon.DPSolveResult}"><code>QuantEcon.bellman_operator!</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Apply the Bellman operator using <code>v=ddpr.v</code>, <code>Tv=ddpr.Tv</code>, and <code>sigma=ddpr.sigma</code></p><p><strong>Notes</strong></p><p>Updates <code>ddpr.Tv</code> and <code>ddpr.sigma</code> inplace</p></div><a class="source-link" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/tree/f744b5bd0dbe0f65cf0ff32bc5a744948435e4ec/src/markov/ddp.jl#L323">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantEcon.bellman_operator-Tuple{QuantEcon.DiscreteDP,Array{T,1}}" href="#QuantEcon.bellman_operator-Tuple{QuantEcon.DiscreteDP,Array{T,1}}"><code>QuantEcon.bellman_operator</code></a> — <span class="docstring-category">Method</span>.</div><div><p>The Bellman operator, which computes and returns the updated value function <span>$Tv$</span> for a given value function <span>$v$</span>.</p><p><strong>Parameters</strong></p><ul><li><p><code>ddp::DiscreteDP</code>: The ddp model</p></li><li><p><code>v::Vector</code>: The current guess of the value function</p></li></ul><p><strong>Returns</strong></p><ul><li><p><code>Tv::Vector</code> : Updated value function vector</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/tree/f744b5bd0dbe0f65cf0ff32bc5a744948435e4ec/src/markov/ddp.jl#L365">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantEcon.bisect-Tuple{Function,T&lt;:AbstractFloat,T&lt;:AbstractFloat}" href="#QuantEcon.bisect-Tuple{Function,T&lt;:AbstractFloat,T&lt;:AbstractFloat}"><code>QuantEcon.bisect</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Find the root of the <code>f</code> on the bracketing inverval <code>[x1, x2]</code> via bisection.</p><p><strong>Arguments</strong></p><ul><li><p><code>f::Function</code>: The function you want to bracket</p></li><li><p><code>x1::T</code>: Lower border for search interval</p></li><li><p><code>x2::T</code>: Upper border for search interval</p></li><li><p><code>;maxiter::Int(500)</code>: Maximum number of bisection iterations</p></li><li><p><code>;xtol::Float64(1e-12)</code>: The routine converges when a root is known to lie within <code>xtol</code> of the value return. Should be &gt;= 0. The routine modifies this to take into account the relative precision of doubles.</p></li><li><p><code>;rtol::Float64(2*eps())</code>:The routine converges when a root is known to lie within <code>rtol</code> times the value returned of the value returned. Should be ≥ 0</p></li></ul><p><strong>Returns</strong></p><ul><li><p><code>x::T</code>: The found root</p></li></ul><p><strong>Exceptions</strong></p><ul><li><p>Throws an <code>ArgumentError</code> if <code>[x1, x2]</code> does not form a bracketing interval</p></li><li><p>Throws a <code>ConvergenceError</code> if the maximum number of iterations is exceeded</p></li></ul><p><strong>References</strong></p><p>Matches <code>bisect</code> function from scipy/scipy/optimize/Zeros/bisect.c</p></div><a class="source-link" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/tree/f744b5bd0dbe0f65cf0ff32bc5a744948435e4ec/src/zeros.jl#L171-L179">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantEcon.brent-Tuple{Function,T&lt;:AbstractFloat,T&lt;:AbstractFloat}" href="#QuantEcon.brent-Tuple{Function,T&lt;:AbstractFloat,T&lt;:AbstractFloat}"><code>QuantEcon.brent</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Find the root of the <code>f</code> on the bracketing inverval <code>[x1, x2]</code> via brent&#39;s algo.</p><p><strong>Arguments</strong></p><ul><li><p><code>f::Function</code>: The function you want to bracket</p></li><li><p><code>x1::T</code>: Lower border for search interval</p></li><li><p><code>x2::T</code>: Upper border for search interval</p></li><li><p><code>;maxiter::Int(500)</code>: Maximum number of bisection iterations</p></li><li><p><code>;xtol::Float64(1e-12)</code>: The routine converges when a root is known to lie within <code>xtol</code> of the value return. Should be &gt;= 0. The routine modifies this to take into account the relative precision of doubles.</p></li><li><p><code>;rtol::Float64(2*eps())</code>:The routine converges when a root is known to lie within <code>rtol</code> times the value returned of the value returned. Should be ≥ 0</p></li></ul><p><strong>Returns</strong></p><ul><li><p><code>x::T</code>: The found root</p></li></ul><p><strong>Exceptions</strong></p><ul><li><p>Throws an <code>ArgumentError</code> if <code>[x1, x2]</code> does not form a bracketing interval</p></li><li><p>Throws a <code>ConvergenceError</code> if the maximum number of iterations is exceeded</p></li></ul><p><strong>References</strong></p><p>Matches <code>brentq</code> function from scipy/scipy/optimize/Zeros/bisectq.c</p></div><a class="source-link" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/tree/f744b5bd0dbe0f65cf0ff32bc5a744948435e4ec/src/zeros.jl#L324-L332">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantEcon.brenth-Tuple{Function,T&lt;:AbstractFloat,T&lt;:AbstractFloat}" href="#QuantEcon.brenth-Tuple{Function,T&lt;:AbstractFloat,T&lt;:AbstractFloat}"><code>QuantEcon.brenth</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Find a root of the <code>f</code> on the bracketing inverval <code>[x1, x2]</code> via modified brent</p><p>This routine uses a hyperbolic extrapolation formula instead of the standard inverse quadratic formula. Otherwise it is the original Brent&#39;s algorithm, as implemented in the <code>brent</code> function.</p><p><strong>Arguments</strong></p><ul><li><p><code>f::Function</code>: The function you want to bracket</p></li><li><p><code>x1::T</code>: Lower border for search interval</p></li><li><p><code>x2::T</code>: Upper border for search interval</p></li><li><p><code>;maxiter::Int(500)</code>: Maximum number of bisection iterations</p></li><li><p><code>;xtol::Float64(1e-12)</code>: The routine converges when a root is known to lie within <code>xtol</code> of the value return. Should be &gt;= 0. The routine modifies this to take into account the relative precision of doubles.</p></li><li><p><code>;rtol::Float64(2*eps())</code>:The routine converges when a root is known to lie within <code>rtol</code> times the value returned of the value returned. Should be ≥ 0</p></li></ul><p><strong>Returns</strong></p><ul><li><p><code>x::T</code>: The found root</p></li></ul><p><strong>Exceptions</strong></p><ul><li><p>Throws an <code>ArgumentError</code> if <code>[x1, x2]</code> does not form a bracketing interval</p></li><li><p>Throws a <code>ConvergenceError</code> if the maximum number of iterations is exceeded</p></li></ul><p><strong>References</strong></p><p>Matches <code>brenth</code> function from scipy/scipy/optimize/Zeros/bisecth.c</p></div><a class="source-link" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/tree/f744b5bd0dbe0f65cf0ff32bc5a744948435e4ec/src/zeros.jl#L338-L350">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantEcon.ckron" href="#QuantEcon.ckron"><code>QuantEcon.ckron</code></a> — <span class="docstring-category">Function</span>.</div><div><p><code>ckron(arrays::AbstractArray...)</code></p><p>Repeatedly apply kronecker products to the arrays. Equilvalent to <code>reduce(kron, arrays)</code></p></div><a class="source-link" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/tree/f744b5bd0dbe0f65cf0ff32bc5a744948435e4ec/src/util.jl#L26-L31">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantEcon.communication_classes-Tuple{QuantEcon.MarkovChain}" href="#QuantEcon.communication_classes-Tuple{QuantEcon.MarkovChain}"><code>QuantEcon.communication_classes</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Find the communication classes of the Markov chain <code>mc</code>.</p><p><strong>Arguments</strong></p><ul><li><p><code>mc::MarkovChain</code> : MarkovChain instance.</p></li></ul><p><strong>Returns</strong></p><ul><li><p><code>::Vector{Vector{Int}}</code> : Vector of vectors that describe the communication classes of <code>mc</code>.</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/tree/f744b5bd0dbe0f65cf0ff32bc5a744948435e4ec/src/markov/mc_tools.jl#L167-L179">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantEcon.compute_deterministic_entropy-Tuple{QuantEcon.RBLQ,Any,Any,Any}" href="#QuantEcon.compute_deterministic_entropy-Tuple{QuantEcon.RBLQ,Any,Any,Any}"><code>QuantEcon.compute_deterministic_entropy</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Given <span>$K$</span> and <span>$F$</span>, compute the value of deterministic entropy, which is  <span>$\sum_t \beta^t x_t&#39; K&#39;K x_t$</span> with <span>$x_{t+1} = (A - BF + CK) x_t$</span>.</p><p><strong>Arguments</strong></p><ul><li><p><code>rlq::RBLQ</code>: Instance of <code>RBLQ</code> type</p></li><li><p><code>F::Matrix{Float64}</code> The policy function, a <code>k x n</code> array</p></li><li><p><code>K::Matrix{Float64}</code> The worst case matrix, a <code>j x n</code> array</p></li><li><p><code>x0::Vector{Float64}</code> : The initial condition for state</p></li></ul><p><strong>Returns</strong></p><ul><li><p><code>e::Float64</code> The deterministic entropy</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/tree/f744b5bd0dbe0f65cf0ff32bc5a744948435e4ec/src/robustlq.jl#L288">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantEcon.compute_fixed_point-Tuple{Function,TV}" href="#QuantEcon.compute_fixed_point-Tuple{Function,TV}"><code>QuantEcon.compute_fixed_point</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Repeatedly apply a function to search for a fixed point</p><p>Approximates <span>$T^∞ v$</span>, where <span>$T$</span> is an operator (function) and <span>$v$</span> is an initial guess for the fixed point. Will terminate either when <code>T^{k+1}(v) - T^k v &lt; err_tol</code> or <code>max_iter</code> iterations has been exceeded.</p><p>Provided that <span>$T$</span> is a contraction mapping or similar,  the return value will be an approximation to the fixed point of <span>$T$</span>.</p><p><strong>Arguments</strong></p><ul><li><p><code>T</code>: A function representing the operator <span>$T$</span></p></li><li><p><code>v::TV</code>: The initial condition. An object of type <span>$TV$</span></p></li><li><p><code>;err_tol(1e-3)</code>: Stopping tolerance for iterations</p></li><li><p><code>;max_iter(50)</code>: Maximum number of iterations</p></li><li><p><code>;verbose(2)</code>: Level of feedback (0 for no output, 1 for warnings only, 2       for warning and convergence messages during iteration)</p></li><li><p><code>;print_skip(10)</code> : if <code>verbose == 2</code>, how many iterations to apply between       print messages</p></li></ul><p><strong>Returns</strong></p><hr/><ul><li><p>&#39;::TV&#39;: The fixed point of the operator <span>$T$</span>. Has type <span>$TV$</span></p></li></ul><p><strong>Example</strong></p><pre><code class="language-julia">using QuantEcon
T(x, μ) = 4.0 * μ * x * (1.0 - x)
x_star = compute_fixed_point(x-&gt;T(x, 0.3), 0.4)  # (4μ - 1)/(4μ)</code></pre></div><a class="source-link" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/tree/f744b5bd0dbe0f65cf0ff32bc5a744948435e4ec/src/compute_fp.jl#L16">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantEcon.compute_greedy!-Tuple{QuantEcon.DiscreteDP,QuantEcon.DPSolveResult}" href="#QuantEcon.compute_greedy!-Tuple{QuantEcon.DiscreteDP,QuantEcon.DPSolveResult}"><code>QuantEcon.compute_greedy!</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Compute the <span>$v$</span>-greedy policy</p><p><strong>Parameters</strong></p><ul><li><p><code>ddp::DiscreteDP</code> : Object that contains the model parameters</p></li><li><p><code>ddpr::DPSolveResult</code> : Object that contains result variables</p></li></ul><p><strong>Returns</strong></p><ul><li><p><code>sigma::Vector{Int}</code> : Array containing <code>v</code>-greedy policy rule</p></li></ul><p><strong>Notes</strong></p><p>modifies ddpr.sigma and ddpr.Tv in place</p></div><a class="source-link" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/tree/f744b5bd0dbe0f65cf0ff32bc5a744948435e4ec/src/markov/ddp.jl#L385">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantEcon.compute_greedy-Tuple{QuantEcon.DiscreteDP,Array{TV&lt;:Real,1}}" href="#QuantEcon.compute_greedy-Tuple{QuantEcon.DiscreteDP,Array{TV&lt;:Real,1}}"><code>QuantEcon.compute_greedy</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Compute the <span>$v$</span>-greedy policy.</p><p><strong>Arguments</strong></p><ul><li><p><code>v::Vector</code> Value function vector of length <code>n</code></p></li><li><p><code>ddp::DiscreteDP</code> Object that contains the model parameters</p></li></ul><p><strong>Returns</strong></p><ul><li><p><code>sigma:: v-greedy policy vector, of length</code>n`</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/tree/f744b5bd0dbe0f65cf0ff32bc5a744948435e4ec/src/markov/ddp.jl#L405">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantEcon.compute_sequence" href="#QuantEcon.compute_sequence"><code>QuantEcon.compute_sequence</code></a> — <span class="docstring-category">Function</span>.</div><div><p>Compute and return the optimal state and control sequence, assuming innovation <span>$N(0,1)$</span></p><p><strong>Arguments</strong></p><ul><li><p><code>lq::LQ</code> : instance of <code>LQ</code> type</p></li><li><p><code>x0::ScalarOrArray</code>: initial state</p></li><li><p><code>ts_length::Integer(100)</code> : maximum number of periods for which to return process. If <code>lq</code> instance is finite horizon type, the sequenes are returned only for <code>min(ts_length, lq.capT)</code></p></li></ul><p><strong>Returns</strong></p><ul><li><p><code>x_path::Matrix{Float64}</code> : An <code>n x T+1</code> matrix, where the t-th column represents <span>$x_t$</span></p></li><li><p><code>u_path::Matrix{Float64}</code> : A <code>k x T</code> matrix, where the t-th column represents <span>$u_t$</span></p></li><li><p><code>w_path::Matrix{Float64}</code> : A <code>n x T+1</code> matrix, where the t-th column represents <code>lq.C*N(0,1)</code></p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/tree/f744b5bd0dbe0f65cf0ff32bc5a744948435e4ec/src/lqcontrol.jl#L286">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantEcon.d_operator-Tuple{QuantEcon.RBLQ,Array{T,2}}" href="#QuantEcon.d_operator-Tuple{QuantEcon.RBLQ,Array{T,2}}"><code>QuantEcon.d_operator</code></a> — <span class="docstring-category">Method</span>.</div><div><p>The <span>$D$</span> operator, mapping <span>$P$</span> into</p><div>\[    D(P) := P + PC(\theta I - C&#39;PC)^{-1} C&#39;P\]</div><p><strong>Arguments</strong></p><ul><li><p><code>rlq::RBLQ</code>: Instance of <code>RBLQ</code> type</p></li><li><p><code>P::Matrix{Float64}</code> : size is <code>n x n</code></p></li></ul><p><strong>Returns</strong></p><ul><li><p><code>dP::Matrix{Float64}</code> : The matrix <span>$P$</span> after applying the <span>$D$</span> operator</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/tree/f744b5bd0dbe0f65cf0ff32bc5a744948435e4ec/src/robustlq.jl#L70">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantEcon.divide_bracket" href="#QuantEcon.divide_bracket"><code>QuantEcon.divide_bracket</code></a> — <span class="docstring-category">Function</span>.</div><div><p>Given a function <code>f</code> defined on the interval <code>[x1, x2]</code>, subdivide the interval into <code>n</code> equally spaced segments, and search for zero crossings of the function. <code>nroot</code> will be set to the number of bracketing pairs found. If it is positive, the arrays <code>xb1[1..nroot]</code> and <code>xb2[1..nroot]</code> will be filled sequentially with any bracketing pairs that are found.</p><p><strong>Arguments</strong></p><ul><li><p><code>f::Function</code>: The function you want to bracket</p></li><li><p><code>x1::T</code>: Lower border for search interval</p></li><li><p><code>x2::T</code>: Upper border for search interval</p></li><li><p><code>n::Int(50)</code>: The number of sub-intervals to divide <code>[x1, x2]</code> into</p></li></ul><p><strong>Returns</strong></p><ul><li><p><code>x1b::Vector{T}</code>: <code>Vector</code> of lower borders of bracketing intervals</p></li><li><p><code>x2b::Vector{T}</code>: <code>Vector</code> of upper borders of bracketing intervals</p></li></ul><p><strong>References</strong></p><p>This is <code>zbrack</code> from Numerical Recepies Recepies in C++</p></div><a class="source-link" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/tree/f744b5bd0dbe0f65cf0ff32bc5a744948435e4ec/src/zeros.jl#L98-L120">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantEcon.do_quad-Tuple{Function,Array,Array{T,1},Vararg{Any,N}}" href="#QuantEcon.do_quad-Tuple{Function,Array,Array{T,1},Vararg{Any,N}}"><code>QuantEcon.do_quad</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Approximate the integral of <code>f</code>, given quadrature <code>nodes</code> and <code>weights</code></p><p><strong>Arguments</strong></p><ul><li><p><code>f::Function</code>: A callable function that is to be approximated over the domain spanned by <code>nodes</code>.</p></li><li><p><code>nodes::Array</code>: Quadrature nodes</p></li><li><p><code>weights::Array</code>: Quadrature nodes</p></li><li><p><code>args...(Void)</code>: additional positional arguments to pass to <code>f</code></p></li><li><p><code>;kwargs...(Void)</code>: additional keyword arguments to pass to <code>f</code></p></li></ul><p><strong>Returns</strong></p><ul><li><p><code>out::Float64</code> : The scalar that approximates integral of <code>f</code> on the hypercube formed by <code>[a, b]</code></p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/tree/f744b5bd0dbe0f65cf0ff32bc5a744948435e4ec/src/quad.jl#L739-L756">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantEcon.estimate_mc_discrete-Tuple{Array{T,1},Array{T,1}}" href="#QuantEcon.estimate_mc_discrete-Tuple{Array{T,1},Array{T,1}}"><code>QuantEcon.estimate_mc_discrete</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Accepts the simulation of a discrete state Markov chain and estimates the transition probabilities</p><p>Let <span>$S = s_1, s_2, \ldots, s_N$</span> with <span>$s_1 &lt; s_2 &lt; \ldots &lt; s_N$</span> be the discrete states of a Markov chain. Furthermore, let <span>$P$</span> be the corresponding stochastic transition matrix.</p><p>Given a history of observations, <span>$\{X\}_{t=0}^{T}$</span> with <span>$x_t \in S \forall t$</span>, we would like to estimate the transition probabilities in <span>$P$</span> with <span>$p_{ij}$</span> as the ith row and jth column of <span>$P$</span>. For <span>$x_t = s_i$</span> and <span>$x_{t-1} = s_j$</span>, let <span>$P(x_t | x_{t-1})$</span> be defined as <span>$p_{i,j}$</span> element of the stochastic matrix. The likelihood function is then given by</p><div>\[  L(\{X\}^t; P) = \text{Prob}(x_1) \prod_{t=2}^{T} P(x_t | x_{t-1})\]</div><p>The maximum likelihood estimate is then just given by the number of times a transition from <span>$s_i$</span> to <span>$s_j$</span> is observed divided by the number of times <span>$s_i$</span> was observed.</p><p>Note: Because of the estimation procedure used, only states that are observed in the history appear in the estimated Markov chain... It can&#39;t divine whether there are unobserved states in the original Markov chain.</p><p>For more info, refer to:</p><ul><li><p>http://www.stat.cmu.edu/~cshalizi/462/lectures/06/markov-mle.pdf</p></li><li><p>https://stats.stackexchange.com/questions/47685/calculating-log-likelihood-for-given-mle-markov-chains</p></li></ul><p><strong>Arguments</strong></p><ul><li><p><code>X::Vector{T}</code> : Simulated history of Markov states</p></li></ul><p><strong>Returns</strong></p><ul><li><p><code>mc::MarkovChain{T}</code> : A Markov chain holding the state values and transition matrix</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/tree/f744b5bd0dbe0f65cf0ff32bc5a744948435e4ec/src/markov/markov_approx.jl#L141">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantEcon.evaluate_F-Tuple{QuantEcon.RBLQ,Array{T,2}}" href="#QuantEcon.evaluate_F-Tuple{QuantEcon.RBLQ,Array{T,2}}"><code>QuantEcon.evaluate_F</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Given a fixed policy <span>$F$</span>, with the interpretation <span>$u = -F x$</span>, this function computes the matrix <span>$P_F$</span> and constant <span>$d_F$</span> associated with discounted cost <span>$J_F(x) = x&#39; P_F x + d_F$</span>.</p><p><strong>Arguments</strong></p><ul><li><p><code>rlq::RBLQ</code>: Instance of <code>RBLQ</code> type</p></li><li><p><code>F::Matrix{Float64}</code> :  The policy function, a <code>k x n</code> array</p></li></ul><p><strong>Returns</strong></p><ul><li><p><code>P_F::Matrix{Float64}</code> : Matrix for discounted cost</p></li><li><p><code>d_F::Float64</code> : Constant for discounted cost</p></li><li><p><code>K_F::Matrix{Float64}</code> : Worst case policy</p></li><li><p><code>O_F::Matrix{Float64}</code> : Matrix for discounted entropy</p></li><li><p><code>o_F::Float64</code> : Constant for discounted entropy</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/tree/f744b5bd0dbe0f65cf0ff32bc5a744948435e4ec/src/robustlq.jl#L312">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantEcon.evaluate_policy-Tuple{QuantEcon.DiscreteDP,Array{T&lt;:Integer,1}}" href="#QuantEcon.evaluate_policy-Tuple{QuantEcon.DiscreteDP,Array{T&lt;:Integer,1}}"><code>QuantEcon.evaluate_policy</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Compute the value of a policy.</p><p><strong>Parameters</strong></p><ul><li><p><code>ddp::DiscreteDP</code> : Object that contains the model parameters</p></li><li><p><code>sigma::Vector{T&lt;:Integer}</code> : Policy rule vector</p></li></ul><p><strong>Returns</strong></p><ul><li><p><code>v_sigma::Array{Float64}</code> : Value vector of <code>sigma</code>, of length <code>n</code>.</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/tree/f744b5bd0dbe0f65cf0ff32bc5a744948435e4ec/src/markov/ddp.jl#L437-L449">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantEcon.evaluate_policy-Tuple{QuantEcon.DiscreteDP,QuantEcon.DPSolveResult}" href="#QuantEcon.evaluate_policy-Tuple{QuantEcon.DiscreteDP,QuantEcon.DPSolveResult}"><code>QuantEcon.evaluate_policy</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Method of <code>evaluate_policy</code> that extracts sigma from a <code>DPSolveResult</code></p><p>See other docstring for details</p></div><a class="source-link" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/tree/f744b5bd0dbe0f65cf0ff32bc5a744948435e4ec/src/markov/ddp.jl#L429-L433">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantEcon.expand_bracket-Tuple{Function,T&lt;:Number,T&lt;:Number}" href="#QuantEcon.expand_bracket-Tuple{Function,T&lt;:Number,T&lt;:Number}"><code>QuantEcon.expand_bracket</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Given a function <code>f</code> and an initial guessed range <code>x1</code> to <code>x2</code>, the routine expands the range geometrically until a root is bracketed by the returned values <code>x1</code> and <code>x2</code> (in which case zbrac returns true) or until the range becomes unacceptably large (in which case a <code>ConvergenceError</code> is thrown).</p><p><strong>Arguments</strong></p><ul><li><p><code>f::Function</code>: The function you want to bracket</p></li><li><p><code>x1::T</code>: Initial guess for lower border of bracket</p></li><li><p><code>x2::T</code>: Initial guess ofr upper border of bracket</p></li><li><p><code>;ntry::Int(50)</code>: The maximum number of expansion iterations</p></li><li><p><code>;fac::Float64(1.6)</code>: Expansion factor (higher ⟶ larger interval size jumps)</p></li></ul><p><strong>Returns</strong></p><ul><li><p><code>x1::T</code>: The lower end of an actual bracketing interval</p></li><li><p><code>x2::T</code>: The upper end of an actual bracketing interval</p></li></ul><p><strong>References</strong></p><p>This method is <code>zbrac</code> from numerical recipies in C++</p><p><strong>Exceptions</strong></p><ul><li><p>Throws a <code>ConvergenceError</code> if the maximum number of iterations is exceeded</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/tree/f744b5bd0dbe0f65cf0ff32bc5a744948435e4ec/src/zeros.jl#L43-L69">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantEcon.filtered_to_forecast!-Tuple{QuantEcon.Kalman}" href="#QuantEcon.filtered_to_forecast!-Tuple{QuantEcon.Kalman}"><code>QuantEcon.filtered_to_forecast!</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Updates the moments of the time <span>$t$</span> filtering distribution to the moments of the predictive distribution, which becomes the time <span>$t+1$</span> prior</p><p><strong>Arguments</strong></p><ul><li><p><code>k::Kalman</code> An instance of the Kalman filter</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/tree/f744b5bd0dbe0f65cf0ff32bc5a744948435e4ec/src/kalman.jl#L81-L89">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantEcon.gridmake" href="#QuantEcon.gridmake"><code>QuantEcon.gridmake</code></a> — <span class="docstring-category">Function</span>.</div><div><p><code>gridmake(arrays::Union{AbstractVector,AbstractMatrix}...)</code></p><p>Expand one or more vectors (or matrices) into a matrix where rows span the cartesian product of combinations of the input arrays. Each column of the input arrays will correspond to one column of the output matrix. The first array varies the fastest (see example)</p><p><strong>Example</strong></p><pre><code class="language-jlcon">julia&gt; x = [1, 2, 3]; y = [10, 20]; z = [100, 200];

julia&gt; gridmake(x, y, z)
12x3 Array{Int64,2}:
 1  10  100
 2  10  100
 3  10  100
 1  20  100
 2  20  100
 3  20  100
 1  10  200
 2  10  200
 3  10  200
 1  20  200
 2  20  200
 3  20  200</code></pre></div><a class="source-link" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/tree/f744b5bd0dbe0f65cf0ff32bc5a744948435e4ec/src/util.jl#L92-L120">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantEcon.gridmake!-Tuple{Any,Vararg{Union{AbstractArray{T,1},AbstractArray{T,2}},N}}" href="#QuantEcon.gridmake!-Tuple{Any,Vararg{Union{AbstractArray{T,1},AbstractArray{T,2}},N}}"><code>QuantEcon.gridmake!</code></a> — <span class="docstring-category">Method</span>.</div><div><p><code>gridmake!(out::AbstractMatrix, arrays::AbstractVector...)</code></p><p>Like <code>gridmake</code>, but fills a pre-populated array. <code>out</code> must have size <code>prod(map(length, arrays), length(arrays))</code></p></div><a class="source-link" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/tree/f744b5bd0dbe0f65cf0ff32bc5a744948435e4ec/src/util.jl#L34-L39">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantEcon.gth_solve-Tuple{Array{T&lt;:Real,2}}" href="#QuantEcon.gth_solve-Tuple{Array{T&lt;:Real,2}}"><code>QuantEcon.gth_solve</code></a> — <span class="docstring-category">Method</span>.</div><div><p>This routine computes the stationary distribution of an irreducible Markov transition matrix (stochastic matrix) or transition rate matrix (generator matrix) <span>$A$</span>.</p><p>More generally, given a Metzler matrix (square matrix whose off-diagonal entries are all nonnegative) <span>$A$</span>, this routine solves for a nonzero solution <span>$x$</span> to <span>$x (A - D) = 0$</span>, where <span>$D$</span> is the diagonal matrix for which the rows of <span>$A - D$</span> sum to zero (i.e., <span>$D_{ii} = \sum_j A_{ij}$</span> for all <span>$i$</span>). One (and only one, up to normalization) nonzero solution exists corresponding to each reccurent class of <span>$A$</span>, and in particular, if <span>$A$</span> is irreducible, there is a unique solution; when there are more than one solution, the routine returns the solution that contains in its support the first index <span>$i$</span> such that no path connects <span>$i$</span> to any index larger than <span>$i$</span>. The solution is normalized so that its 1-norm equals one. This routine implements the Grassmann-Taksar-Heyman (GTH) algorithm (Grassmann, Taksar, and Heyman 1985), a numerically stable variant of Gaussian elimination, where only the off-diagonal entries of <span>$A$</span> are used as the input data. For a nice exposition of the algorithm, see Stewart (2009), Chapter 10.</p><p><strong>Arguments</strong></p><ul><li><p><code>A::Matrix{T}</code> : Stochastic matrix or generator matrix. Must be of shape n x n.</p></li></ul><p><strong>Returns</strong></p><ul><li><p><code>x::Vector{T}</code> : Stationary distribution of <span>$A$</span>.</p></li></ul><p><strong>References</strong></p><ul><li><p>W. K. Grassmann, M. I. Taksar and D. P. Heyman, &quot;Regenerative Analysis and Steady State Distributions for Markov Chains, &quot; Operations Research (1985), 1107-1116.</p></li><li><p>W. J. Stewart, Probability, Markov Chains, Queues, and Simulation, Princeton University Press, 2009.</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/tree/f744b5bd0dbe0f65cf0ff32bc5a744948435e4ec/src/markov/mc_tools.jl#L72">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantEcon.impulse_response-Tuple{QuantEcon.ARMA}" href="#QuantEcon.impulse_response-Tuple{QuantEcon.ARMA}"><code>QuantEcon.impulse_response</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Get the impulse response corresponding to our model.</p><p><strong>Arguments</strong></p><ul><li><p><code>arma::ARMA</code>: Instance of <code>ARMA</code> type</p></li><li><p><code>;impulse_length::Integer(30)</code>: Length of horizon for calcluating impulse reponse. Must be at least as long as the <code>p</code> fields of <code>arma</code></p></li></ul><p><strong>Returns</strong></p><ul><li><p><code>psi::Vector{Float64}</code>: <code>psi[j]</code> is the response at lag j of the impulse response. We take <code>psi[1]</code> as unity.</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/tree/f744b5bd0dbe0f65cf0ff32bc5a744948435e4ec/src/arma.jl#L152">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantEcon.interp-Tuple{AbstractArray{T,1},AbstractArray{T,1}}" href="#QuantEcon.interp-Tuple{AbstractArray{T,1},AbstractArray{T,1}}"><code>QuantEcon.interp</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">interp(grid::AbstractVector, function_vals::AbstractVector)</code></pre><p>Linear interpolation in one dimension</p><p><strong>Examples</strong></p><pre><code class="language-julia">breaks = cumsum(0.1 .* rand(20))
vals = 0.1 .* sin.(breaks)
li = interp(breaks, vals)

# Do interpolation by treating `li` as a function you can pass scalars to
li(0.2)

# use broadcasting to evaluate at multiple points
li.([0.1, 0.2, 0.3])</code></pre></div><a class="source-link" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/tree/f744b5bd0dbe0f65cf0ff32bc5a744948435e4ec/src/interp.jl#L135-L153">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantEcon.is_aperiodic-Tuple{QuantEcon.MarkovChain}" href="#QuantEcon.is_aperiodic-Tuple{QuantEcon.MarkovChain}"><code>QuantEcon.is_aperiodic</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Indicate whether the Markov chain <code>mc</code> is aperiodic.</p><p><strong>Arguments</strong></p><ul><li><p><code>mc::MarkovChain</code> : MarkovChain instance.</p></li></ul><p><strong>Returns</strong></p><ul><li><p><code>::Bool</code></p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/tree/f744b5bd0dbe0f65cf0ff32bc5a744948435e4ec/src/markov/mc_tools.jl#L196-L207">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantEcon.is_irreducible-Tuple{QuantEcon.MarkovChain}" href="#QuantEcon.is_irreducible-Tuple{QuantEcon.MarkovChain}"><code>QuantEcon.is_irreducible</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Indicate whether the Markov chain <code>mc</code> is irreducible.</p><p><strong>Arguments</strong></p><ul><li><p><code>mc::MarkovChain</code> : MarkovChain instance.</p></li></ul><p><strong>Returns</strong></p><ul><li><p><code>::Bool</code></p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/tree/f744b5bd0dbe0f65cf0ff32bc5a744948435e4ec/src/markov/mc_tools.jl#L182-L193">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantEcon.lae_est-Tuple{QuantEcon.LAE,AbstractArray{T,N}}" href="#QuantEcon.lae_est-Tuple{QuantEcon.LAE,AbstractArray{T,N}}"><code>QuantEcon.lae_est</code></a> — <span class="docstring-category">Method</span>.</div><div><p>A vectorized function that returns the value of the look ahead estimate at the values in the array <code>y</code>.</p><p><strong>Arguments</strong></p><ul><li><p><code>l::LAE</code>: Instance of <code>LAE</code> type</p></li><li><p><code>y::Array</code>: Array that becomes the <code>y</code> in <code>l.p(l.x, y)</code></p></li></ul><p><strong>Returns</strong></p><ul><li><p><code>psi_vals::Vector</code>: Density at <code>(x, y)</code></p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/tree/f744b5bd0dbe0f65cf0ff32bc5a744948435e4ec/src/lae.jl#L44-L57">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantEcon.m_quadratic_sum-Tuple{Array{T,2},Array{T,2}}" href="#QuantEcon.m_quadratic_sum-Tuple{Array{T,2},Array{T,2}}"><code>QuantEcon.m_quadratic_sum</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Computes the quadratic sum</p><div>\[    V = \sum_{j=0}^{\infty} A^j B A^{j&#39;}\]</div><p><span>$V$</span> is computed by solving the corresponding discrete lyapunov equation using the doubling algorithm.  See the documentation of <code>solve_discrete_lyapunov</code> for more information.</p><p><strong>Arguments</strong></p><ul><li><p><code>A::Matrix{Float64}</code> : An <code>n x n</code> matrix as described above.  We assume in order for convergence that the eigenvalues of <span>$A$</span> have moduli bounded by unity</p></li><li><p><code>B::Matrix{Float64}</code> : An <code>n x n</code> matrix as described above.  We assume in order for convergence that the eigenvalues of <span>$B$</span> have moduli bounded by unity</p></li><li><p><code>max_it::Int(50)</code> : Maximum number of iterations</p></li></ul><p><strong>Returns</strong></p><ul><li><p><code>gamma1::Matrix{Float64}</code> : Represents the value <span>$V$</span></p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/tree/f744b5bd0dbe0f65cf0ff32bc5a744948435e4ec/src/quadsums.jl#L61">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantEcon.moment_sequence-Tuple{QuantEcon.LSS}" href="#QuantEcon.moment_sequence-Tuple{QuantEcon.LSS}"><code>QuantEcon.moment_sequence</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Create an iterator to calculate the population mean and variance-convariance matrix for both <span>$x_t$</span> and <span>$y_t$</span>, starting at the initial condition <code>(self.mu_0, self.Sigma_0)</code>.  Each iteration produces a 4-tuple of items <code>(mu_x, mu_y, Sigma_x, Sigma_y)</code> for the next period.</p><p><strong>Arguments</strong></p><ul><li><p><code>lss::LSS</code> An instance of the Gaussian linear state space model</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/tree/f744b5bd0dbe0f65cf0ff32bc5a744948435e4ec/src/lss.jl#L161">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantEcon.n_states-Tuple{QuantEcon.MarkovChain}" href="#QuantEcon.n_states-Tuple{QuantEcon.MarkovChain}"><code>QuantEcon.n_states</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Number of states in the Markov chain <code>mc</code></p></div><a class="source-link" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/tree/f744b5bd0dbe0f65cf0ff32bc5a744948435e4ec/src/markov/mc_tools.jl#L63">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantEcon.nnash-Tuple{Any,Any,Any,Any,Any,Any,Any,Any,Any,Any,Any,Any,Any}" href="#QuantEcon.nnash-Tuple{Any,Any,Any,Any,Any,Any,Any,Any,Any,Any,Any,Any,Any}"><code>QuantEcon.nnash</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Compute the limit of a Nash linear quadratic dynamic game.</p><p>Player <code>i</code> minimizes</p><div>\[    \sum_{t=1}^{\infty}(x_t&#39; r_i x_t + 2 x_t&#39; w_i
    u_{it} +u_{it}&#39; q_i u_{it} + u_{jt}&#39; s_i u_{jt} + 2 u_{jt}&#39;
    m_i u_{it})\]</div><p>subject to the law of motion</p><div>\[    x_{t+1} = A x_t + b_1 u_{1t} + b_2 u_{2t}\]</div><p>and a perceived control law <span>$u_j(t) = - f_j x_t$</span> for the other player.</p><p>The solution computed in this routine is the <span>$f_i$</span> and <span>$p_i$</span> of the associated double optimal linear regulator problem.</p><p><strong>Arguments</strong></p><ul><li><p><code>A</code> : Corresponds to the above equation, should be of size <code>(n, n)</code></p></li><li><p><code>B1</code> : As above, size <code>(n, k_1)</code></p></li><li><p><code>B2</code> : As above, size <code>(n, k_2)</code></p></li><li><p><code>R1</code> : As above, size <code>(n, n)</code></p></li><li><p><code>R2</code> : As above, size <code>(n, n)</code></p></li><li><p><code>Q1</code> : As above, size <code>(k_1, k_1)</code></p></li><li><p><code>Q2</code> : As above, size <code>(k_2, k_2)</code></p></li><li><p><code>S1</code> : As above, size <code>(k_1, k_1)</code></p></li><li><p><code>S2</code> : As above, size <code>(k_2, k_2)</code></p></li><li><p><code>W1</code> : As above, size <code>(n, k_1)</code></p></li><li><p><code>W2</code> : As above, size <code>(n, k_2)</code></p></li><li><p><code>M1</code> : As above, size <code>(k_2, k_1)</code></p></li><li><p><code>M2</code> : As above, size <code>(k_1, k_2)</code></p></li><li><p><code>;beta::Float64(1.0)</code> Discount rate</p></li><li><p><code>;tol::Float64(1e-8)</code> : Tolerance level for convergence</p></li><li><p><code>;max_iter::Int(1000)</code> : Maximum number of iterations allowed</p></li></ul><p><strong>Returns</strong></p><ul><li><p><code>F1::Matrix{Float64}</code>: <code>(k_1, n)</code> matrix representing feedback law for agent 1</p></li><li><p><code>F2::Matrix{Float64}</code>: <code>(k_2, n)</code> matrix representing feedback law for agent 2</p></li><li><p><code>P1::Matrix{Float64}</code>: <code>(n, n)</code> matrix representing the steady-state solution to the associated discrete matrix ticcati equation for agent 1</p></li><li><p><code>P2::Matrix{Float64}</code>: <code>(n, n)</code> matrix representing the steady-state solution to the associated discrete matrix riccati equation for agent 2</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/tree/f744b5bd0dbe0f65cf0ff32bc5a744948435e4ec/src/lqnash.jl#L12">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantEcon.periodogram" href="#QuantEcon.periodogram"><code>QuantEcon.periodogram</code></a> — <span class="docstring-category">Function</span>.</div><div><p>Computes the periodogram</p><div>\[I(w) = \frac{1}{n} | \sum_{t=0}^{n-1} x_t e^{itw} |^2\]</div><p>at the Fourier frequences <span>$w_j := 2 \frac{\pi j}{n}, j = 0, \ldots, n - 1$</span>, using the fast Fourier transform.  Only the frequences <span>$w_j$</span> in <span>$[0, \pi]$</span> and corresponding values <span>$I(w_j)$</span> are returned.  If a window type is given then smoothing is performed.</p><p><strong>Arguments</strong></p><ul><li><p><code>x::Array</code>: An array containing the data to smooth</p></li><li><p><code>window_len::Int(7)</code>: An odd integer giving the length of the window</p></li><li><p><code>window::AbstractString(&quot;hanning&quot;)</code>: A string giving the window type. Possible values are <code>flat</code>, <code>hanning</code>, <code>hamming</code>, <code>bartlett</code>, or <code>blackman</code></p></li></ul><p><strong>Returns</strong></p><ul><li><p><code>w::Array{Float64}</code>: Fourier frequencies at which the periodogram is evaluated</p></li><li><p><code>I_w::Array{Float64}</code>: The periodogram at frequences <code>w</code></p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/tree/f744b5bd0dbe0f65cf0ff32bc5a744948435e4ec/src/estspec.jl#L93">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantEcon.prior_to_filtered!-Tuple{QuantEcon.Kalman,Any}" href="#QuantEcon.prior_to_filtered!-Tuple{QuantEcon.Kalman,Any}"><code>QuantEcon.prior_to_filtered!</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Updates the moments (<code>cur_x_hat</code>, <code>cur_sigma</code>) of the time <span>$t$</span> prior to the time <span>$t$</span> filtering distribution, using current measurement <span>$y_t$</span>. The updates are according to</p><div>\[    \hat{x}^F = \hat{x} + \Sigma G&#39; (G \Sigma G&#39; + R)^{-1}
                    (y - G \hat{x}) \\
                    
    \Sigma^F = \Sigma - \Sigma G&#39; (G \Sigma G&#39; + R)^{-1} G
               \Sigma\]</div><p><strong>Arguments</strong></p><ul><li><p><code>k::Kalman</code> An instance of the Kalman filter</p></li><li><p><code>y</code> The current measurement</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/tree/f744b5bd0dbe0f65cf0ff32bc5a744948435e4ec/src/kalman.jl#L45">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantEcon.qnwbeta-Tuple{Int64,Real,Real}" href="#QuantEcon.qnwbeta-Tuple{Int64,Real,Real}"><code>QuantEcon.qnwbeta</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Computes nodes and weights for beta distribution.</p><p><strong>Arguments</strong></p><ul><li><p><code>n::Union{Int, Vector{Int}}</code> : Number of desired nodes along each dimension</p></li><li><p><code>a::Union{Real, Vector{Real}}</code> : First parameter of the beta distribution, along each dimension</p></li><li><p><code>b::Union{Real, Vector{Real}}</code> : Second parameter of the beta distribution, along each dimension</p></li></ul><p><strong>Returns</strong></p><ul><li><p><code>nodes::Array{Float64}</code> : An array of quadrature nodes</p></li><li><p><code>weights::Array{Float64}</code> : An array of corresponding quadrature weights</p></li></ul><p><strong>Notes</strong></p><p>If any of the parameters to this function are scalars while others are vectors of length <code>n</code>, the the scalar parameter is repeated <code>n</code> times.</p><p><strong>References</strong></p><p>Miranda, Mario J, and Paul L Fackler. Applied Computational Economics and Finance, MIT Press, 2002.</p></div><a class="source-link" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/tree/f744b5bd0dbe0f65cf0ff32bc5a744948435e4ec/src/quad.jl#L284-L300">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantEcon.qnwcheb-Tuple{Int64,Real,Real}" href="#QuantEcon.qnwcheb-Tuple{Int64,Real,Real}"><code>QuantEcon.qnwcheb</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Computes multivariate Guass-Checbychev quadrature nodes and weights.</p><p><strong>Arguments</strong></p><ul><li><p><code>n::Union{Int, Vector{Int}}</code> : Number of desired nodes along each dimension</p></li><li><p><code>a::Union{Real, Vector{Real}}</code> : Lower endpoint along each dimension</p></li><li><p><code>b::Union{Real, Vector{Real}}</code> : Upper endpoint along each dimension</p></li></ul><p><strong>Returns</strong></p><ul><li><p><code>nodes::Array{Float64}</code> : An array of quadrature nodes</p></li><li><p><code>weights::Array{Float64}</code> : An array of corresponding quadrature weights</p></li></ul><p><strong>Notes</strong></p><p>If any of the parameters to this function are scalars while others are vectors of length <code>n</code>, the the scalar parameter is repeated <code>n</code> times.</p><p><strong>References</strong></p><p>Miranda, Mario J, and Paul L Fackler. Applied Computational Economics and Finance, MIT Press, 2002.</p></div><a class="source-link" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/tree/f744b5bd0dbe0f65cf0ff32bc5a744948435e4ec/src/quad.jl#L105-L119">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantEcon.qnwequi" href="#QuantEcon.qnwequi"><code>QuantEcon.qnwequi</code></a> — <span class="docstring-category">Function</span>.</div><div><p>Generates equidistributed sequences with property that averages value of integrable function evaluated over the sequence converges to the integral as n goes to infinity.</p><p><strong>Arguments</strong></p><ul><li><p><code>n::Union{Int, Vector{Int}}</code> : Number of desired nodes along each dimension</p></li><li><p><code>a::Union{Real, Vector{Real}}</code> : Lower endpoint along each dimension</p></li><li><p><code>b::Union{Real, Vector{Real}}</code> : Upper endpoint along each dimension</p></li><li><p><code>kind::AbstractString(&quot;N&quot;)</code>: One of the following:</p><ul><li><p>N - Neiderreiter (default)</p></li><li><p>W - Weyl</p></li><li><p>H - Haber</p></li><li><p>R - pseudo Random</p></li></ul></li></ul><p><strong>Returns</strong></p><ul><li><p><code>nodes::Array{Float64}</code> : An array of quadrature nodes</p></li><li><p><code>weights::Array{Float64}</code> : An array of corresponding quadrature weights</p></li></ul><p><strong>Notes</strong></p><p>If any of the parameters to this function are scalars while others are vectors of length <code>n</code>, the the scalar parameter is repeated <code>n</code> times.</p><p><strong>References</strong></p><p>Miranda, Mario J, and Paul L Fackler. Applied Computational Economics and Finance, MIT Press, 2002.</p></div><a class="source-link" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/tree/f744b5bd0dbe0f65cf0ff32bc5a744948435e4ec/src/quad.jl#L650-L672">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantEcon.qnwgamma" href="#QuantEcon.qnwgamma"><code>QuantEcon.qnwgamma</code></a> — <span class="docstring-category">Function</span>.</div><div><p>Computes nodes and weights for beta distribution</p><p><strong>Arguments</strong></p><ul><li><p><code>n::Union{Int, Vector{Int}}</code> : Number of desired nodes along each dimension</p></li><li><p><code>a::Union{Real, Vector{Real}}</code> : Shape parameter of the gamma distribution, along each dimension. Must be positive. Default is 1</p></li><li><p><code>b::Union{Real, Vector{Real}}</code> : Scale parameter of the gamma distribution, along each dimension. Must be positive. Default is 1</p></li></ul><p><strong>Returns</strong></p><ul><li><p><code>nodes::Array{Float64}</code> : An array of quadrature nodes</p></li><li><p><code>weights::Array{Float64}</code> : An array of corresponding quadrature weights</p></li></ul><p><strong>Notes</strong></p><p>If any of the parameters to this function are scalars while others are vectors of length <code>n</code>, the the scalar parameter is repeated <code>n</code> times.</p><p><strong>References</strong></p><p>Miranda, Mario J, and Paul L Fackler. Applied Computational Economics and Finance, MIT Press, 2002.</p></div><a class="source-link" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/tree/f744b5bd0dbe0f65cf0ff32bc5a744948435e4ec/src/quad.jl#L393-L409">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantEcon.qnwlege-Tuple{Int64,Real,Real}" href="#QuantEcon.qnwlege-Tuple{Int64,Real,Real}"><code>QuantEcon.qnwlege</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Computes multivariate Guass-Legendre  quadrature nodes and weights.</p><p><strong>Arguments</strong></p><ul><li><p><code>n::Union{Int, Vector{Int}}</code> : Number of desired nodes along each dimension</p></li><li><p><code>a::Union{Real, Vector{Real}}</code> : Lower endpoint along each dimension</p></li><li><p><code>b::Union{Real, Vector{Real}}</code> : Upper endpoint along each dimension</p></li></ul><p><strong>Returns</strong></p><ul><li><p><code>nodes::Array{Float64}</code> : An array of quadrature nodes</p></li><li><p><code>weights::Array{Float64}</code> : An array of corresponding quadrature weights</p></li></ul><p><strong>Notes</strong></p><p>If any of the parameters to this function are scalars while others are vectors of length <code>n</code>, the the scalar parameter is repeated <code>n</code> times.</p><p><strong>References</strong></p><p>Miranda, Mario J, and Paul L Fackler. Applied Computational Economics and Finance, MIT Press, 2002.</p></div><a class="source-link" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/tree/f744b5bd0dbe0f65cf0ff32bc5a744948435e4ec/src/quad.jl#L38-L52">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantEcon.qnwlogn-Tuple{Any,Any,Any}" href="#QuantEcon.qnwlogn-Tuple{Any,Any,Any}"><code>QuantEcon.qnwlogn</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Computes quadrature nodes and weights for multivariate uniform distribution</p><p><strong>Arguments</strong></p><ul><li><p><code>n::Union{Int, Vector{Int}}</code> : Number of desired nodes along each dimension</p></li><li><p><code>mu::Union{Real, Vector{Real}}</code> : Mean along each dimension</p></li><li><p><code>sig2::Union{Real, Vector{Real}, Matrix{Real}}(eye(length(n)))</code> : Covariance structure</p></li></ul><p><strong>Returns</strong></p><ul><li><p><code>nodes::Array{Float64}</code> : An array of quadrature nodes</p></li><li><p><code>weights::Array{Float64}</code> : An array of corresponding quadrature weights</p></li></ul><p><strong>Notes</strong></p><p>See also the documentation for <code>qnwnorm</code></p><p><strong>References</strong></p><p>Miranda, Mario J, and Paul L Fackler. Applied Computational Economics and Finance, MIT Press, 2002.</p></div><a class="source-link" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/tree/f744b5bd0dbe0f65cf0ff32bc5a744948435e4ec/src/quad.jl#L621-L639">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantEcon.qnwnorm-Tuple{Int64}" href="#QuantEcon.qnwnorm-Tuple{Int64}"><code>QuantEcon.qnwnorm</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Computes nodes and weights for multivariate normal distribution.</p><p><strong>Arguments</strong></p><ul><li><p><code>n::Union{Int, Vector{Int}}</code> : Number of desired nodes along each dimension</p></li><li><p><code>mu::Union{Real, Vector{Real}}</code> : Mean along each dimension</p></li><li><p><code>sig2::Union{Real, Vector{Real}, Matrix{Real}}(eye(length(n)))</code> : Covariance structure</p></li></ul><p><strong>Returns</strong></p><ul><li><p><code>nodes::Array{Float64}</code> : An array of quadrature nodes</p></li><li><p><code>weights::Array{Float64}</code> : An array of corresponding quadrature weights</p></li></ul><p><strong>Notes</strong></p><p>This function has many methods. I try to describe them here.</p><p><code>n</code> or <code>mu</code> can be a vector or a scalar. If just one is a scalar the other is repeated to match the length of the other. If both are scalars, then the number of repeats is inferred from <code>sig2</code>.</p><p><code>sig2</code> can be a matrix, vector or scalar. If it is a matrix, it is treated as the covariance matrix. If it is a vector, it is considered the diagonal of a diagonal covariance matrix. If it is a scalar it is repeated along the diagonal as many times as necessary, where the number of repeats is determined by the length of either <code>n</code> and/or <code>mu</code> (which ever is a vector).</p><p>If all 3 are scalars, then 1d nodes are computed. <code>mu</code> and <code>sig2</code> are treated as the mean and variance of a 1d normal distribution</p><p><strong>References</strong></p><p>Miranda, Mario J, and Paul L Fackler. Applied Computational Economics and Finance, MIT Press, 2002.</p></div><a class="source-link" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/tree/f744b5bd0dbe0f65cf0ff32bc5a744948435e4ec/src/quad.jl#L127-L157">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantEcon.qnwsimp-Tuple{Int64,Real,Real}" href="#QuantEcon.qnwsimp-Tuple{Int64,Real,Real}"><code>QuantEcon.qnwsimp</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Computes multivariate Simpson quadrature nodes and weights.</p><p><strong>Arguments</strong></p><ul><li><p><code>n::Union{Int, Vector{Int}}</code> : Number of desired nodes along each dimension</p></li><li><p><code>a::Union{Real, Vector{Real}}</code> : Lower endpoint along each dimension</p></li><li><p><code>b::Union{Real, Vector{Real}}</code> : Upper endpoint along each dimension</p></li></ul><p><strong>Returns</strong></p><ul><li><p><code>nodes::Array{Float64}</code> : An array of quadrature nodes</p></li><li><p><code>weights::Array{Float64}</code> : An array of corresponding quadrature weights</p></li></ul><p><strong>Notes</strong></p><p>If any of the parameters to this function are scalars while others are vectors of length <code>n</code>, the the scalar parameter is repeated <code>n</code> times.</p><p><strong>References</strong></p><p>Miranda, Mario J, and Paul L Fackler. Applied Computational Economics and Finance, MIT Press, 2002.</p></div><a class="source-link" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/tree/f744b5bd0dbe0f65cf0ff32bc5a744948435e4ec/src/quad.jl#L222-L236">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantEcon.qnwtrap-Tuple{Int64,Real,Real}" href="#QuantEcon.qnwtrap-Tuple{Int64,Real,Real}"><code>QuantEcon.qnwtrap</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Computes multivariate trapezoid quadrature nodes and weights.</p><p><strong>Arguments</strong></p><ul><li><p><code>n::Union{Int, Vector{Int}}</code> : Number of desired nodes along each dimension</p></li><li><p><code>a::Union{Real, Vector{Real}}</code> : Lower endpoint along each dimension</p></li><li><p><code>b::Union{Real, Vector{Real}}</code> : Upper endpoint along each dimension</p></li></ul><p><strong>Returns</strong></p><ul><li><p><code>nodes::Array{Float64}</code> : An array of quadrature nodes</p></li><li><p><code>weights::Array{Float64}</code> : An array of corresponding quadrature weights</p></li></ul><p><strong>Notes</strong></p><p>If any of the parameters to this function are scalars while others are vectors of length <code>n</code>, the the scalar parameter is repeated <code>n</code> times.</p><p><strong>References</strong></p><p>Miranda, Mario J, and Paul L Fackler. Applied Computational Economics and Finance, MIT Press, 2002.</p></div><a class="source-link" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/tree/f744b5bd0dbe0f65cf0ff32bc5a744948435e4ec/src/quad.jl#L257-L271">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantEcon.qnwunif-Tuple{Any,Any,Any}" href="#QuantEcon.qnwunif-Tuple{Any,Any,Any}"><code>QuantEcon.qnwunif</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Computes quadrature nodes and weights for multivariate uniform distribution.</p><p><strong>Arguments</strong></p><ul><li><p><code>n::Union{Int, Vector{Int}}</code> : Number of desired nodes along each dimension</p></li><li><p><code>a::Union{Real, Vector{Real}}</code> : Lower endpoint along each dimension</p></li><li><p><code>b::Union{Real, Vector{Real}}</code> : Upper endpoint along each dimension</p></li></ul><p><strong>Returns</strong></p><ul><li><p><code>nodes::Array{Float64}</code> : An array of quadrature nodes</p></li><li><p><code>weights::Array{Float64}</code> : An array of corresponding quadrature weights</p></li></ul><p><strong>Notes</strong></p><p>If any of the parameters to this function are scalars while others are vectors of length <code>n</code>, the the scalar parameter is repeated <code>n</code> times.</p><p><strong>References</strong></p><p>Miranda, Mario J, and Paul L Fackler. Applied Computational Economics and Finance, MIT Press, 2002.</p></div><a class="source-link" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/tree/f744b5bd0dbe0f65cf0ff32bc5a744948435e4ec/src/quad.jl#L600-L614">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantEcon.quadrect" href="#QuantEcon.quadrect"><code>QuantEcon.quadrect</code></a> — <span class="docstring-category">Function</span>.</div><div><p>Integrate the d-dimensional function <code>f</code> on a rectangle with lower and upper bound for dimension i defined by <code>a[i]</code> and <code>b[i]</code>, respectively; using <code>n[i]</code> points.</p><p><strong>Arguments</strong></p><ul><li><p><code>f::Function</code> The function to integrate over. This should be a function that accepts as its first argument a matrix representing points along each dimension (each dimension is a column). Other arguments that need to be passed to the function are caught by <code>args...</code> and <code>kwargs...</code>`</p></li><li><p><code>n::Union{Int, Vector{Int}}</code> : Number of desired nodes along each dimension</p></li><li><p><code>a::Union{Real, Vector{Real}}</code> : Lower endpoint along each dimension</p></li><li><p><code>b::Union{Real, Vector{Real}}</code> : Upper endpoint along each dimension</p></li><li><p><code>kind::AbstractString(&quot;lege&quot;)</code> Specifies which type of integration to perform. Valid values are:</p><ul><li><p><code>&quot;lege&quot;</code> : Gauss-Legendre</p></li><li><p><code>&quot;cheb&quot;</code> : Gauss-Chebyshev</p></li><li><p><code>&quot;trap&quot;</code> : trapezoid rule</p></li><li><p><code>&quot;simp&quot;</code> : Simpson rule</p></li><li><p><code>&quot;N&quot;</code> : Neiderreiter equidistributed sequence</p></li><li><p><code>&quot;W&quot;</code> : Weyl equidistributed sequence</p></li><li><p><code>&quot;H&quot;</code> : Haber  equidistributed sequence</p></li><li><p><code>&quot;R&quot;</code> : Monte Carlo</p></li><li><p><code>args...(Void)</code>: additional positional arguments to pass to <code>f</code></p></li><li><p><code>;kwargs...(Void)</code>: additional keyword arguments to pass to <code>f</code></p></li></ul></li></ul><p><strong>Returns</strong></p><ul><li><p><code>out::Float64</code> : The scalar that approximates integral of <code>f</code> on the hypercube formed by <code>[a, b]</code></p></li></ul><p><strong>References</strong></p><p>Miranda, Mario J, and Paul L Fackler. Applied Computational Economics and Finance, MIT Press, 2002.</p></div><a class="source-link" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/tree/f744b5bd0dbe0f65cf0ff32bc5a744948435e4ec/src/quad.jl#L763-L796">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantEcon.random_discrete_dp" href="#QuantEcon.random_discrete_dp"><code>QuantEcon.random_discrete_dp</code></a> — <span class="docstring-category">Function</span>.</div><div><p>Generate a DiscreteDP randomly. The reward values are drawn from the normal distribution with mean 0 and standard deviation <code>scale</code>.</p><p><strong>Arguments</strong></p><ul><li><p><code>num_states::Integer</code> : Number of states.</p></li><li><p><code>num_actions::Integer</code> : Number of actions.</p></li><li><p><code>beta::Union{Float64, Void}(nothing)</code> : Discount factor. Randomly chosen from <code>[0, 1)</code> if not specified.</p></li><li><p><code>;k::Union{Integer, Void}(nothing)</code> : Number of possible next states for each state-action pair. Equal to <code>num_states</code> if not specified.</p></li><li><p><code>scale::Real(1)</code> : Standard deviation of the normal distribution for the reward values.</p></li></ul><p><strong>Returns</strong></p><ul><li><p><code>ddp::DiscreteDP</code> : An instance of DiscreteDP.</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/tree/f744b5bd0dbe0f65cf0ff32bc5a744948435e4ec/src/markov/random_mc.jl#L158-L177">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantEcon.random_markov_chain-Tuple{Integer,Integer}" href="#QuantEcon.random_markov_chain-Tuple{Integer,Integer}"><code>QuantEcon.random_markov_chain</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Return a randomly sampled MarkovChain instance with <code>n</code> states, where each state has <code>k</code> states with positive transition probability.</p><p><strong>Arguments</strong></p><ul><li><p><code>n::Integer</code> : Number of states.</p></li></ul><p><strong>Returns</strong></p><ul><li><p><code>mc::MarkovChain</code> : MarkovChain instance.</p></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; using QuantEcon

julia&gt; mc = random_markov_chain(3, 2)
Discrete Markov Chain
stochastic matrix:
3x3 Array{Float64,2}:
 0.369124  0.0       0.630876
 0.519035  0.480965  0.0
 0.0       0.744614  0.255386
</code></pre></div><a class="source-link" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/tree/f744b5bd0dbe0f65cf0ff32bc5a744948435e4ec/src/markov/random_mc.jl#L46-L73">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantEcon.random_markov_chain-Tuple{Integer}" href="#QuantEcon.random_markov_chain-Tuple{Integer}"><code>QuantEcon.random_markov_chain</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Return a randomly sampled MarkovChain instance with <code>n</code> states.</p><p><strong>Arguments</strong></p><ul><li><p><code>n::Integer</code> : Number of states.</p></li></ul><p><strong>Returns</strong></p><ul><li><p><code>mc::MarkovChain</code> : MarkovChain instance.</p></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; using QuantEcon

julia&gt; mc = random_markov_chain(3)
Discrete Markov Chain
stochastic matrix:
3x3 Array{Float64,2}:
 0.281188  0.61799   0.100822
 0.144461  0.848179  0.0073594
 0.360115  0.323973  0.315912
</code></pre></div><a class="source-link" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/tree/f744b5bd0dbe0f65cf0ff32bc5a744948435e4ec/src/markov/random_mc.jl#L12-L38">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantEcon.random_stochastic_matrix" href="#QuantEcon.random_stochastic_matrix"><code>QuantEcon.random_stochastic_matrix</code></a> — <span class="docstring-category">Function</span>.</div><div><p>Return a randomly sampled <code>n x n</code> stochastic matrix with <code>k</code> nonzero entries for each row.</p><p><strong>Arguments</strong></p><ul><li><p><code>n::Integer</code> : Number of states.</p></li><li><p><code>k::Union{Integer, Void}(nothing)</code> : Number of nonzero entries in each column of the matrix. Set to <code>n</code> if none specified.</p></li></ul><p><strong>Returns</strong></p><ul><li><p><code>p::Array</code> : Stochastic matrix.</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/tree/f744b5bd0dbe0f65cf0ff32bc5a744948435e4ec/src/markov/random_mc.jl#L83-L97">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantEcon.recurrent_classes-Tuple{QuantEcon.MarkovChain}" href="#QuantEcon.recurrent_classes-Tuple{QuantEcon.MarkovChain}"><code>QuantEcon.recurrent_classes</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Find the recurrent classes of the Markov chain <code>mc</code>.</p><p><strong>Arguments</strong></p><ul><li><p><code>mc::MarkovChain</code> : MarkovChain instance.</p></li></ul><p><strong>Returns</strong></p><ul><li><p><code>::Vector{Vector{Int}}</code> : Vector of vectors that describe the recurrent classes of <code>mc</code>.</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/tree/f744b5bd0dbe0f65cf0ff32bc5a744948435e4ec/src/markov/mc_tools.jl#L152-L164">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantEcon.replicate" href="#QuantEcon.replicate"><code>QuantEcon.replicate</code></a> — <span class="docstring-category">Function</span>.</div><div><p>Simulate <code>num_reps</code> observations of <span>$x_T$</span> and <span>$y_T$</span> given <span>$x_0 \sim N(\mu_0, \Sigma_0)$</span>.</p><p><strong>Arguments</strong></p><ul><li><p><code>lss::LSS</code> An instance of the Gaussian linear state space model.</p></li><li><p><code>t::Int = 10</code> The period that we want to replicate values for.</p></li><li><p><code>num_reps::Int = 100</code> The number of replications we want</p></li></ul><p><strong>Returns</strong></p><ul><li><p><code>x::Matrix</code> An <code>n x num_reps</code> matrix, where the j-th column is the j_th             observation of <span>$x_T$</span></p></li><li><p><code>y::Matrix</code> An <code>k x num_reps</code> matrix, where the j-th column is the j_th             observation of <span>$y_T$</span></p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/tree/f744b5bd0dbe0f65cf0ff32bc5a744948435e4ec/src/lss.jl#L110">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantEcon.ridder-Tuple{Function,T&lt;:AbstractFloat,T&lt;:AbstractFloat}" href="#QuantEcon.ridder-Tuple{Function,T&lt;:AbstractFloat,T&lt;:AbstractFloat}"><code>QuantEcon.ridder</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Find a root of the <code>f</code> on the bracketing inverval <code>[x1, x2]</code> via ridder algo</p><p><strong>Arguments</strong></p><ul><li><p><code>f::Function</code>: The function you want to bracket</p></li><li><p><code>x1::T</code>: Lower border for search interval</p></li><li><p><code>x2::T</code>: Upper border for search interval</p></li><li><p><code>;maxiter::Int(500)</code>: Maximum number of bisection iterations</p></li><li><p><code>;xtol::Float64(1e-12)</code>: The routine converges when a root is known to lie within <code>xtol</code> of the value return. Should be &gt;= 0. The routine modifies this to take into account the relative precision of doubles.</p></li><li><p><code>;rtol::Float64(2*eps())</code>:The routine converges when a root is known to lie within <code>rtol</code> times the value returned of the value returned. Should be ≥ 0</p></li></ul><p><strong>Returns</strong></p><ul><li><p><code>x::T</code>: The found root</p></li></ul><p><strong>Exceptions</strong></p><ul><li><p>Throws an <code>ArgumentError</code> if <code>[x1, x2]</code> does not form a bracketing interval</p></li><li><p>Throws a <code>ConvergenceError</code> if the maximum number of iterations is exceeded</p></li></ul><p><strong>References</strong></p><p>Matches <code>ridder</code> function from scipy/scipy/optimize/Zeros/ridder.c</p></div><a class="source-link" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/tree/f744b5bd0dbe0f65cf0ff32bc5a744948435e4ec/src/zeros.jl#L358-L366">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantEcon.robust_rule-Tuple{QuantEcon.RBLQ}" href="#QuantEcon.robust_rule-Tuple{QuantEcon.RBLQ}"><code>QuantEcon.robust_rule</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Solves the robust control problem.</p><p>The algorithm here tricks the problem into a stacked LQ problem, as described in chapter 2 of Hansen- Sargent&#39;s text &quot;Robustness&quot;.  The optimal control with observed state is</p><div>\[    u_t = - F x_t\]</div><p>And the value function is <span>$-x&#39;Px$</span></p><p><strong>Arguments</strong></p><ul><li><p><code>rlq::RBLQ</code>: Instance of <code>RBLQ</code> type</p></li></ul><p><strong>Returns</strong></p><ul><li><p><code>F::Matrix{Float64}</code> : The optimal control matrix from above</p></li><li><p><code>P::Matrix{Float64}</code> : The positive semi-definite matrix defining the value function</p></li><li><p><code>K::Matrix{Float64}</code> : the worst-case shock matrix <span>$K$</span>, where <span>$w_{t+1} = K x_t$</span> is the worst case shock</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/tree/f744b5bd0dbe0f65cf0ff32bc5a744948435e4ec/src/robustlq.jl#L132">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantEcon.robust_rule_simple" href="#QuantEcon.robust_rule_simple"><code>QuantEcon.robust_rule_simple</code></a> — <span class="docstring-category">Function</span>.</div><div><p>Solve the robust LQ problem</p><p>A simple algorithm for computing the robust policy <span>$F$</span> and the corresponding value function <span>$P$</span>, based around straightforward iteration with the robust Bellman operator.  This function is easier to understand but one or two orders of magnitude slower than <code>self.robust_rule()</code>.  For more information see the docstring of that method.</p><p><strong>Arguments</strong></p><ul><li><p><code>rlq::RBLQ</code>: Instance of <code>RBLQ</code> type</p></li><li><p><code>P_init::Matrix{Float64}(zeros(rlq.n, rlq.n))</code> : The initial guess for the</p></li></ul><p>value function matrix</p><ul><li><p><code>;max_iter::Int(80)</code>: Maximum number of iterations that are allowed</p></li><li><p><code>;tol::Real(1e-8)</code> The tolerance for convergence</p></li></ul><p><strong>Returns</strong></p><ul><li><p><code>F::Matrix{Float64}</code> : The optimal control matrix from above</p></li><li><p><code>P::Matrix{Float64}</code> : The positive semi-definite matrix defining the value function</p></li><li><p><code>K::Matrix{Float64}</code> : the worst-case shock matrix <span>$K$</span>, where <span>$w_{t+1} = K x_t$</span> is the worst case shock</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/tree/f744b5bd0dbe0f65cf0ff32bc5a744948435e4ec/src/robustlq.jl#L178">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantEcon.rouwenhorst" href="#QuantEcon.rouwenhorst"><code>QuantEcon.rouwenhorst</code></a> — <span class="docstring-category">Function</span>.</div><div><p>Rouwenhorst&#39;s method to approximate AR(1) processes.</p><p>The process follows</p><div>\[    y_t = \mu + \rho y_{t-1} + \epsilon_t\]</div><p>where <span>$\epsilon_t \sim N (0, \sigma^2)$</span></p><p><strong>Arguments</strong></p><ul><li><p><code>N::Integer</code> : Number of points in markov process</p></li><li><p><code>ρ::Real</code> : Persistence parameter in AR(1) process</p></li><li><p><code>σ::Real</code> : Standard deviation of random component of AR(1) process</p></li><li><p><code>μ::Real(0.0)</code> :  Mean of AR(1) process</p></li></ul><p><strong>Returns</strong></p><ul><li><p><code>mc::MarkovChain{Float64}</code> : Markov chain holding the state values and transition matrix</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/tree/f744b5bd0dbe0f65cf0ff32bc5a744948435e4ec/src/markov/markov_approx.jl#L87">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantEcon.simulate!-Tuple{Union{AbstractArray{T,1},AbstractArray{T,2}},QuantEcon.MarkovChain}" href="#QuantEcon.simulate!-Tuple{Union{AbstractArray{T,1},AbstractArray{T,2}},QuantEcon.MarkovChain}"><code>QuantEcon.simulate!</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Fill <code>X</code> with sample paths of the Markov chain <code>mc</code> as columns. The resulting matrix has the state values of <code>mc</code> as elements.</p><p><strong>Arguments</strong></p><ul><li><p><code>X::Matrix</code> : Preallocated matrix to be filled with sample paths</p></li></ul><p>of the Markov chain <code>mc</code>. The element types in <code>X</code> should be the same as the type of the state values of <code>mc</code></p><ul><li><p><code>mc::MarkovChain</code> : MarkovChain instance.</p></li><li><p><code>;init=rand(1:n_states(mc))</code> : Can be one of the following</p><ul><li><p>blank: random initial condition for each chain</p></li><li><p>scalar: same initial condition for each chain</p></li><li><p>vector: cycle through the elements, applying each as an initial condition until all columns have an initial condition (allows for more columns than initial conditions)</p></li></ul></li></ul></div><a class="source-link" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/tree/f744b5bd0dbe0f65cf0ff32bc5a744948435e4ec/src/markov/mc_tools.jl#L368-L384">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantEcon.simulate-Tuple{QuantEcon.MarkovChain,Int64}" href="#QuantEcon.simulate-Tuple{QuantEcon.MarkovChain,Int64}"><code>QuantEcon.simulate</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Simulate one sample path of the Markov chain <code>mc</code>. The resulting vector has the state values of <code>mc</code> as elements.</p><p><strong>Arguments</strong></p><ul><li><p><code>mc::MarkovChain</code> : MarkovChain instance.</p></li><li><p><code>ts_length::Int</code> : Length of simulation</p></li><li><p><code>;init::Int=rand(1:n_states(mc))</code> : Initial state</p></li></ul><p><strong>Returns</strong></p><ul><li><p><code>X::Vector</code> : Vector containing the sample path, with length ts_length</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/tree/f744b5bd0dbe0f65cf0ff32bc5a744948435e4ec/src/markov/mc_tools.jl#L346-L360">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantEcon.simulate_indices!-Tuple{Union{AbstractArray{T&lt;:Integer,1},AbstractArray{T&lt;:Integer,2}},QuantEcon.MarkovChain}" href="#QuantEcon.simulate_indices!-Tuple{Union{AbstractArray{T&lt;:Integer,1},AbstractArray{T&lt;:Integer,2}},QuantEcon.MarkovChain}"><code>QuantEcon.simulate_indices!</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Fill <code>X</code> with sample paths of the Markov chain <code>mc</code> as columns. The resulting matrix has the indices of the state values of <code>mc</code> as elements.</p><p><strong>Arguments</strong></p><ul><li><p><code>X::Matrix{Int}</code> : Preallocated matrix to be filled with indices</p></li></ul><p>of the sample paths of the Markov chain <code>mc</code>.</p><ul><li><p><code>mc::MarkovChain</code> : MarkovChain instance.</p></li><li><p><code>;init=rand(1:n_states(mc))</code> : Can be one of the following</p><ul><li><p>blank: random initial condition for each chain</p></li><li><p>scalar: same initial condition for each chain</p></li><li><p>vector: cycle through the elements, applying each as an initial condition until all columns have an initial condition (allows for more columns than initial conditions)</p></li></ul></li></ul></div><a class="source-link" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/tree/f744b5bd0dbe0f65cf0ff32bc5a744948435e4ec/src/markov/mc_tools.jl#L423-L438">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantEcon.simulate_indices-Tuple{QuantEcon.MarkovChain,Int64}" href="#QuantEcon.simulate_indices-Tuple{QuantEcon.MarkovChain,Int64}"><code>QuantEcon.simulate_indices</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Simulate one sample path of the Markov chain <code>mc</code>. The resulting vector has the indices of the state values of <code>mc</code> as elements.</p><p><strong>Arguments</strong></p><ul><li><p><code>mc::MarkovChain</code> : MarkovChain instance.</p></li><li><p><code>ts_length::Int</code> : Length of simulation</p></li><li><p><code>;init::Int=rand(1:n_states(mc))</code> : Initial state</p></li></ul><p><strong>Returns</strong></p><ul><li><p><code>X::Vector{Int}</code> : Vector containing the sample path, with length ts_length</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/tree/f744b5bd0dbe0f65cf0ff32bc5a744948435e4ec/src/markov/mc_tools.jl#L401-L415">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantEcon.simulation-Tuple{QuantEcon.ARMA}" href="#QuantEcon.simulation-Tuple{QuantEcon.ARMA}"><code>QuantEcon.simulation</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Compute a simulated sample path assuming Gaussian shocks.</p><p><strong>Arguments</strong></p><ul><li><p><code>arma::ARMA</code>: Instance of <code>ARMA</code> type</p></li><li><p><code>;ts_length::Integer(90)</code>: Length of simulation</p></li><li><p><code>;impulse_length::Integer(30)</code>: Horizon for calculating impulse response (see also docstring for <code>impulse_response</code>)</p></li></ul><p><strong>Returns</strong></p><ul><li><p><code>X::Vector{Float64}</code>: Simulation of the ARMA model <code>arma</code></p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/tree/f744b5bd0dbe0f65cf0ff32bc5a744948435e4ec/src/arma.jl#L184-L198">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantEcon.smooth" href="#QuantEcon.smooth"><code>QuantEcon.smooth</code></a> — <span class="docstring-category">Function</span>.</div><div><p>Smooth the data in x using convolution with a window of requested size and type.</p><p><strong>Arguments</strong></p><ul><li><p><code>x::Array</code>: An array containing the data to smooth</p></li><li><p><code>window_len::Int(7)</code>: An odd integer giving the length of the window</p></li><li><p><code>window::AbstractString(&quot;hanning&quot;)</code>: A string giving the window type.  Possible values are <code>flat</code>, <code>hanning</code>, <code>hamming</code>, <code>bartlett</code>, or <code>blackman</code></p></li></ul><p><strong>Returns</strong></p><ul><li><p><code>out::Array</code>: The array of smoothed data</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/tree/f744b5bd0dbe0f65cf0ff32bc5a744948435e4ec/src/estspec.jl#L16-L29">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantEcon.smooth-Tuple{Array}" href="#QuantEcon.smooth-Tuple{Array}"><code>QuantEcon.smooth</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Version of <code>smooth</code> where <code>window_len</code> and <code>window</code> are keyword arguments</p></div><a class="source-link" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/tree/f744b5bd0dbe0f65cf0ff32bc5a744948435e4ec/src/estspec.jl#L69">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantEcon.solve" href="#QuantEcon.solve"><code>QuantEcon.solve</code></a> — <span class="docstring-category">Function</span>.</div><div><p>Solve the dynamic programming problem.</p><p><strong>Parameters</strong></p><ul><li><p><code>ddp::DiscreteDP</code> : Object that contains the Model Parameters</p></li><li><p><code>method::Type{T&lt;Algo}(VFI)</code>: Type name specifying solution method. Acceptable arguments are <code>VFI</code> for value function iteration or <code>PFI</code> for policy function iteration or <code>MPFI</code> for modified policy function iteration</p></li><li><p><code>;max_iter::Int(250)</code> : Maximum number of iterations</p></li><li><p><code>;epsilon::Float64(1e-3)</code> : Value for epsilon-optimality. Only used if <code>method</code> is <code>VFI</code></p></li><li><p><code>;k::Int(20)</code> : Number of iterations for partial policy evaluation in modified policy iteration (irrelevant for other methods).</p></li></ul><p><strong>Returns</strong></p><ul><li><p><code>ddpr::DPSolveResult{Algo}</code> : Optimization result represented as a <code>DPSolveResult</code>. See <code>DPSolveResult</code> for details.</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/tree/f744b5bd0dbe0f65cf0ff32bc5a744948435e4ec/src/markov/ddp.jl#L461-L480">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantEcon.solve_discrete_lyapunov" href="#QuantEcon.solve_discrete_lyapunov"><code>QuantEcon.solve_discrete_lyapunov</code></a> — <span class="docstring-category">Function</span>.</div><div><p>Solves the discrete lyapunov equation.</p><p>The problem is given by</p><div>\[    AXA&#39; - X + B = 0\]</div><p><span>$X$</span> is computed by using a doubling algorithm. In particular, we iterate to convergence on <span>$X_j$</span> with the following recursions for <span>$j = 1, 2, \ldots$</span> starting from <span>$X_0 = B, a_0 = A$</span>:</p><div>\[    a_j = a_{j-1} a_{j-1} \\

    X_j = X_{j-1} + a_{j-1} X_{j-1} a_{j-1}&#39;\]</div><p><strong>Arguments</strong></p><ul><li><p><code>A::Matrix{Float64}</code> : An <code>n x n</code> matrix as described above.  We assume in order for  convergence that the eigenvalues of <span>$A$</span> have moduli bounded by unity</p></li><li><p><code>B::Matrix{Float64}</code> :  An <code>n x n</code> matrix as described above.  We assume in order for convergence that the eigenvalues of <span>$B$</span> have moduli bounded by unity</p></li><li><p><code>max_it::Int(50)</code> :  Maximum number of iterations</p></li></ul><p><strong>Returns</strong></p><ul><li><p><code>gamma1::Matrix{Float64}</code> Represents the value <span>$X$</span></p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/tree/f744b5bd0dbe0f65cf0ff32bc5a744948435e4ec/src/matrix_eqn.jl#L3">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantEcon.solve_discrete_riccati" href="#QuantEcon.solve_discrete_riccati"><code>QuantEcon.solve_discrete_riccati</code></a> — <span class="docstring-category">Function</span>.</div><div><p>Solves the discrete-time algebraic Riccati equation</p><p>The prolem is defined as</p><div>\[    X = A&#39;XA - (N + B&#39;XA)&#39;(B&#39;XB + R)^{-1}(N + B&#39;XA) + Q\]</div><p>via a modified structured doubling algorithm.  An explanation of the algorithm can be found in the reference below.</p><p><strong>Arguments</strong></p><ul><li><p><code>A</code> : <code>k x k</code> array.</p></li><li><p><code>B</code> : <code>k x n</code> array</p></li><li><p><code>R</code> : <code>n x n</code>, should be symmetric and positive definite</p></li><li><p><code>Q</code> : <code>k x k</code>, should be symmetric and non-negative definite</p></li><li><p><code>N::Matrix{Float64}(zeros(size(R, 1), size(Q, 1)))</code> : <code>n x k</code> array</p></li><li><p><code>tolerance::Float64(1e-10)</code> Tolerance level for convergence</p></li><li><p><code>max_iter::Int(50)</code> : The maximum number of iterations allowed</p></li></ul><p>Note that <code>A, B, R, Q</code> can either be real (i.e. <code>k, n = 1</code>) or matrices.</p><p><strong>Returns</strong></p><ul><li><p><code>X::Matrix{Float64}</code> The fixed point of the Riccati equation; a <code>k x k</code> array representing the approximate solution</p></li></ul><p><strong>References</strong></p><p>Chiang, Chun-Yueh, Hung-Yuan Fan, and Wen-Wei Lin. &quot;STRUCTURED DOUBLING ALGORITHM FOR DISCRETE-TIME ALGEBRAIC RICCATI EQUATIONS WITH SINGULAR CONTROL WEIGHTING MATRICES.&quot; Taiwanese Journal of Mathematics 14, no. 3A (2010): pp-935.</p></div><a class="source-link" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/tree/f744b5bd0dbe0f65cf0ff32bc5a744948435e4ec/src/matrix_eqn.jl#L68">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantEcon.spectral_density-Tuple{QuantEcon.ARMA}" href="#QuantEcon.spectral_density-Tuple{QuantEcon.ARMA}"><code>QuantEcon.spectral_density</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Compute the spectral density function.</p><p>The spectral density is the discrete time Fourier transform of the autocovariance function. In particular,</p><div>\[    f(w) = \sum_k \gamma(k) \exp(-ikw)\]</div><p>where <span>$\gamma$</span> is the autocovariance function and the sum is over the set of all integers.</p><p><strong>Arguments</strong></p><ul><li><p><code>arma::ARMA</code>: Instance of <code>ARMA</code> type</p></li><li><p><code>;two_pi::Bool(true)</code>: Compute the spectral density function over <span>$[0, \pi]$</span> if false and <span>$[0, 2 \pi]$</span> otherwise.</p></li><li><p><code>;res(1200)</code> : If <code>res</code> is a scalar then the spectral density is computed at <code>res</code> frequencies evenly spaced around the unit circle, but if <code>res</code> is an array then the function computes the response at the frequencies given by the array</p></li></ul><p><strong>Returns</strong></p><ul><li><p><code>w::Vector{Float64}</code>: The normalized frequencies at which h was computed, in radians/sample</p></li><li><p><code>spect::Vector{Float64}</code> : The frequency response</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/tree/f744b5bd0dbe0f65cf0ff32bc5a744948435e4ec/src/arma.jl#L94">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantEcon.stationary_distributions" href="#QuantEcon.stationary_distributions"><code>QuantEcon.stationary_distributions</code></a> — <span class="docstring-category">Function</span>.</div><div><p>Compute stationary distributions of the Markov chain <code>mc</code>, one for each recurrent class.</p><p><strong>Arguments</strong></p><ul><li><p><code>mc::MarkovChain{T}</code> : MarkovChain instance.</p></li></ul><p><strong>Returns</strong></p><ul><li><p><code>stationary_dists::Vector{Vector{T1}}</code> : Vector of vectors that represent stationary distributions, where the element type <code>T1</code> is <code>Rational</code> if <code>T</code> is <code>Int</code> (and equal to <code>T</code> otherwise).</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/tree/f744b5bd0dbe0f65cf0ff32bc5a744948435e4ec/src/markov/mc_tools.jl#L259-L273">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantEcon.stationary_distributions-Tuple{QuantEcon.LSS}" href="#QuantEcon.stationary_distributions-Tuple{QuantEcon.LSS}"><code>QuantEcon.stationary_distributions</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Compute the moments of the stationary distributions of <span>$x_t$</span> and <span>$y_t$</span> if possible.  Computation is by iteration, starting from the initial conditions <code>lss.mu_0</code> and <code>lss.Sigma_0</code></p><p><strong>Arguments</strong></p><ul><li><p><code>lss::LSS</code> An instance of the Guassian linear state space model</p></li><li><p><code>;max_iter::Int = 200</code> The maximum number of iterations allowed</p></li><li><p><code>;tol::Float64 = 1e-5</code> The tolerance level one wishes to achieve</p></li></ul><p><strong>Returns</strong></p><ul><li><p><code>mu_x::Vector</code> Represents the stationary mean of <span>$x_t$</span></p></li><li><p><code>mu_y::Vector</code> Represents the stationary mean of <span>$y_t$</span></p></li><li><p><code>Sigma_x::Matrix</code> Represents the var-cov matrix</p></li><li><p><code>Sigma_y::Matrix</code> Represents the var-cov matrix</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/tree/f744b5bd0dbe0f65cf0ff32bc5a744948435e4ec/src/lss.jl#L176">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantEcon.stationary_values!-Tuple{QuantEcon.LQ}" href="#QuantEcon.stationary_values!-Tuple{QuantEcon.LQ}"><code>QuantEcon.stationary_values!</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Computes value and policy functions in infinite horizon model.</p><p><strong>Arguments</strong></p><ul><li><p><code>lq::LQ</code> : instance of <code>LQ</code> type</p></li></ul><p><strong>Returns</strong></p><ul><li><p><code>P::ScalarOrArray</code> : n x n matrix in value function representation <span>$V(x) = x&#39;Px + d$</span></p></li><li><p><code>d::Real</code> : Constant in value function representation</p></li><li><p><code>F::ScalarOrArray</code> : Policy rule that specifies optimal control in each period</p></li></ul><p><strong>Notes</strong></p><p>This function updates the <code>P</code>, <code>d</code>, and <code>F</code> fields on the <code>lq</code> instance in addition to returning them</p></div><a class="source-link" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/tree/f744b5bd0dbe0f65cf0ff32bc5a744948435e4ec/src/lqcontrol.jl#L177">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantEcon.stationary_values-Tuple{QuantEcon.LQ}" href="#QuantEcon.stationary_values-Tuple{QuantEcon.LQ}"><code>QuantEcon.stationary_values</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Non-mutating routine for solving for <code>P</code>, <code>d</code>, and <code>F</code> in infinite horizon model</p><p>See docstring for <code>stationary_values!</code> for more explanation</p></div><a class="source-link" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/tree/f744b5bd0dbe0f65cf0ff32bc5a744948435e4ec/src/lqcontrol.jl#L216-L220">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantEcon.tauchen" href="#QuantEcon.tauchen"><code>QuantEcon.tauchen</code></a> — <span class="docstring-category">Function</span>.</div><div><p>Tauchen&#39;s (1996) method for approximating AR(1) process with finite markov chain</p><p>The process follows</p><div>\[    y_t = \mu + \rho y_{t-1} + \epsilon_t\]</div><p>where <span>$\epsilon_t \sim N (0, \sigma^2)$</span></p><p><strong>Arguments</strong></p><ul><li><p><code>N::Integer</code>: Number of points in markov process</p></li><li><p><code>ρ::Real</code> : Persistence parameter in AR(1) process</p></li><li><p><code>σ::Real</code> : Standard deviation of random component of AR(1) process</p></li><li><p><code>μ::Real(0.0)</code> : Mean of AR(1) process</p></li><li><p><code>n_std::Integer(3)</code> : The number of standard deviations to each side the process should span</p></li></ul><p><strong>Returns</strong></p><ul><li><p><code>mc::MarkovChain{Float64}</code> : Markov chain holding the state values and transition matrix</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/tree/f744b5bd0dbe0f65cf0ff32bc5a744948435e4ec/src/markov/markov_approx.jl#L17">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantEcon.update!-Tuple{QuantEcon.Kalman,Any}" href="#QuantEcon.update!-Tuple{QuantEcon.Kalman,Any}"><code>QuantEcon.update!</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Updates <code>cur_x_hat</code> and <code>cur_sigma</code> given array <code>y</code> of length <code>k</code>.  The full update, from one period to the next</p><p><strong>Arguments</strong></p><ul><li><p><code>k::Kalman</code> An instance of the Kalman filter</p></li><li><p><code>y</code> An array representing the current measurement</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/tree/f744b5bd0dbe0f65cf0ff32bc5a744948435e4ec/src/kalman.jl#L101-L110">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantEcon.update_values!-Tuple{QuantEcon.LQ}" href="#QuantEcon.update_values!-Tuple{QuantEcon.LQ}"><code>QuantEcon.update_values!</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Update <code>P</code> and <code>d</code> from the value function representation in finite horizon case</p><p><strong>Arguments</strong></p><ul><li><p><code>lq::LQ</code> : instance of <code>LQ</code> type</p></li></ul><p><strong>Returns</strong></p><ul><li><p><code>P::ScalarOrArray</code> : <code>n x n</code> matrix in value function representation <span>$V(x) = x&#39;Px + d$</span></p></li><li><p><code>d::Real</code> : Constant in value function representation</p></li></ul><p><strong>Notes</strong></p><p>This function updates the <code>P</code> and <code>d</code> fields on the <code>lq</code> instance in addition to returning them</p></div><a class="source-link" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/tree/f744b5bd0dbe0f65cf0ff32bc5a744948435e4ec/src/lqcontrol.jl#L136">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantEcon.var_quadratic_sum-Tuple{Union{Array{T,N},T},Union{Array{T,N},T},Union{Array{T,N},T},Real,Union{Array{T,N},T}}" href="#QuantEcon.var_quadratic_sum-Tuple{Union{Array{T,N},T},Union{Array{T,N},T},Union{Array{T,N},T},Real,Union{Array{T,N},T}}"><code>QuantEcon.var_quadratic_sum</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Computes the expected discounted quadratic sum</p><div>\[    q(x_0) = \mathbb{E} \sum_{t=0}^{\infty} \beta^t x_t&#39; H x_t\]</div><p>Here <span>${x_t}$</span> is the VAR process <span>$x_{t+1} = A x_t + C w_t$</span> with <span>${w_t}$</span> standard normal and <span>$x_0$</span> the initial condition.</p><p><strong>Arguments</strong></p><ul><li><p><code>A::Union{Float64, Matrix{Float64}}</code> The <code>n x n</code> matrix described above (scalar) if <code>n = 1</code></p></li><li><p><code>C::Union{Float64, Matrix{Float64}}</code> The <code>n x n</code> matrix described above (scalar) if <code>n = 1</code></p></li><li><p><code>H::Union{Float64, Matrix{Float64}}</code> The <code>n x n</code> matrix described above (scalar) if <code>n = 1</code></p></li><li><p><code>beta::Float64</code>: Discount factor in <code>(0, 1)</code></p></li><li><p><code>x_0::Union{Float64, Vector{Float64}}</code> The initial condtion. A conformable array (of length <code>n</code>) or a scalar if <code>n = 1</code></p></li></ul><p><strong>Returns</strong></p><ul><li><p><code>q0::Float64</code> : Represents the value <span>$q(x_0)$</span></p></li></ul><p><strong>Notes</strong></p><p>The formula for computing <span>$q(x_0)$</span> is <span>$q(x_0) = x_0&#39; Q x_0 + v$</span> where</p><ul><li><p><span>$Q$</span> is the solution to <span>$Q = H + \beta A&#39; Q A$</span> and</p></li><li><p><span>$v = \frac{trace(C&#39; Q C) \beta}{1 - \beta}$</span></p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/tree/f744b5bd0dbe0f65cf0ff32bc5a744948435e4ec/src/quadsums.jl#L9">source</a><br/></section><h2><a class="nav-anchor" id="Internal-1" href="#Internal-1">Internal</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.e-Tuple{Real}" href="#Base.e-Tuple{Real}"><code>Base.e</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Evaluate the empirical cdf at one or more points</p><p><strong>Arguments</strong></p><ul><li><p><code>x::Union{Real, Array}</code>: The point(s) at which to evaluate the ECDF</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/tree/f744b5bd0dbe0f65cf0ff32bc5a744948435e4ec/src/ecdf.jl#L24-L30">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantEcon.DPSolveResult" href="#QuantEcon.DPSolveResult"><code>QuantEcon.DPSolveResult</code></a> — <span class="docstring-category">Type</span>.</div><div><p><code>DPSolveResult</code> is an object for retaining results and associated metadata after solving the model</p><p><strong>Parameters</strong></p><ul><li><p><code>ddp::DiscreteDP</code> : DiscreteDP object</p></li></ul><p><strong>Returns</strong></p><ul><li><p><code>ddpr::DPSolveResult</code> : DiscreteDP results object</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/tree/f744b5bd0dbe0f65cf0ff32bc5a744948435e4ec/src/markov/ddp.jl#L252-L264">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:*-Tuple{Array{T,3},Array{T,1}}" href="#Base.:*-Tuple{Array{T,3},Array{T,1}}"><code>Base.:*</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Define Matrix Multiplication between 3-dimensional matrix and a vector</p><p>Matrix multiplication over the last dimension of <span>$A$</span></p></div><a class="source-link" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/tree/f744b5bd0dbe0f65cf0ff32bc5a744948435e4ec/src/markov/ddp.jl#L729">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Random.rand-Tuple{QuantEcon.DiscreteRV,Int64}" href="#Base.Random.rand-Tuple{QuantEcon.DiscreteRV,Int64}"><code>Base.Random.rand</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Make multiple draws from the discrete distribution represented by a <code>DiscreteRV</code> instance</p><p><strong>Arguments</strong></p><ul><li><p><code>d::DiscreteRV</code>: The <code>DiscreteRV</code> type representing the distribution</p></li><li><p><code>k::Int</code></p></li></ul><p><strong>Returns</strong></p><ul><li><p><code>out::Vector{Int}</code>: <code>k</code> draws from <code>d</code></p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/tree/f744b5bd0dbe0f65cf0ff32bc5a744948435e4ec/src/discrete_rv.jl#L58-L70">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Random.rand-Tuple{QuantEcon.DiscreteRV}" href="#Base.Random.rand-Tuple{QuantEcon.DiscreteRV}"><code>Base.Random.rand</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Make a single draw from the discrete distribution.</p><p><strong>Arguments</strong></p><ul><li><p><code>d::DiscreteRV</code>: The <code>DiscreteRV</code> type represetning the distribution</p></li></ul><p><strong>Returns</strong></p><ul><li><p><code>out::Int</code>: One draw from the discrete distribution</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/tree/f744b5bd0dbe0f65cf0ff32bc5a744948435e4ec/src/discrete_rv.jl#L45-L55">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantEcon._compute_sequence-Tuple{QuantEcon.LQ,Array{T,1},Any}" href="#QuantEcon._compute_sequence-Tuple{QuantEcon.LQ,Array{T,1},Any}"><code>QuantEcon._compute_sequence</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Private method implementing <code>compute_sequence</code> when state is a scalar</p></div><a class="source-link" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/tree/f744b5bd0dbe0f65cf0ff32bc5a744948435e4ec/src/lqcontrol.jl#L259-L261">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantEcon._compute_sequence-Tuple{QuantEcon.LQ,T,Any}" href="#QuantEcon._compute_sequence-Tuple{QuantEcon.LQ,T,Any}"><code>QuantEcon._compute_sequence</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Private method implementing <code>compute_sequence</code> when state is a scalar</p></div><a class="source-link" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/tree/f744b5bd0dbe0f65cf0ff32bc5a744948435e4ec/src/lqcontrol.jl#L236-L238">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantEcon._generate_a_indptr!-Tuple{Int64,Array{T,1},Array{T,1}}" href="#QuantEcon._generate_a_indptr!-Tuple{Int64,Array{T,1},Array{T,1}}"><code>QuantEcon._generate_a_indptr!</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Generate <code>a_indptr</code>; stored in <code>out</code>. <code>s_indices</code> is assumed to be in sorted order.</p><p><strong>Parameters</strong></p><ul><li><p><code>num_states::Integer</code></p></li><li><p><code>s_indices::Vector{T}</code></p></li><li><p><code>out::Vector{T}</code> :  with length = <code>num_states</code> + 1</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/tree/f744b5bd0dbe0f65cf0ff32bc5a744948435e4ec/src/markov/ddp.jl#L693-L703">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantEcon._has_sorted_sa_indices-Tuple{Array{T,1},Array{T,1}}" href="#QuantEcon._has_sorted_sa_indices-Tuple{Array{T,1},Array{T,1}}"><code>QuantEcon._has_sorted_sa_indices</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Check whether <code>s_indices</code> and <code>a_indices</code> are sorted in lexicographic order.</p><p><strong>Parameters</strong></p><p><code>s_indices</code>, <code>a_indices</code> : Vectors</p><p><strong>Returns</strong></p><p>bool: Whether <code>s_indices</code> and <code>a_indices</code> are sorted.</p></div><a class="source-link" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/tree/f744b5bd0dbe0f65cf0ff32bc5a744948435e4ec/src/markov/ddp.jl#L667-L677">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantEcon._random_stochastic_matrix-Tuple{Integer,Integer}" href="#QuantEcon._random_stochastic_matrix-Tuple{Integer,Integer}"><code>QuantEcon._random_stochastic_matrix</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Generate a &quot;non-square column stochstic matrix&quot; of shape <code>(n, m)</code>, which contains as columns <code>m</code> probability vectors of length <code>n</code> with <code>k</code> nonzero entries.</p><p><strong>Arguments</strong></p><ul><li><p><code>n::Integer</code> : Number of states.</p></li><li><p><code>m::Integer</code> : Number of probability vectors.</p></li><li><p><code>;k::Union{Integer, Void}(nothing)</code> : Number of nonzero entries in each column of the matrix. Set to <code>n</code> if none specified.</p></li></ul><p><strong>Returns</strong></p><ul><li><p><code>p::Array</code> : Array of shape <code>(n, m)</code> containing <code>m</code> probability vectors of length <code>n</code> as columns.</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/tree/f744b5bd0dbe0f65cf0ff32bc5a744948435e4ec/src/markov/random_mc.jl#L112-L128">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantEcon._solve!-Tuple{QuantEcon.DiscreteDP,QuantEcon.DPSolveResult{QuantEcon.MPFI,Tval&lt;:Real},Integer,Real,Integer}" href="#QuantEcon._solve!-Tuple{QuantEcon.DiscreteDP,QuantEcon.DPSolveResult{QuantEcon.MPFI,Tval&lt;:Real},Integer,Real,Integer}"><code>QuantEcon._solve!</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Modified Policy Function Iteration</p></div><a class="source-link" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/tree/f744b5bd0dbe0f65cf0ff32bc5a744948435e4ec/src/markov/ddp.jl#L803-L805">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantEcon._solve!-Tuple{QuantEcon.DiscreteDP,QuantEcon.DPSolveResult{QuantEcon.PFI,Tval&lt;:Real},Integer,Real,Integer}" href="#QuantEcon._solve!-Tuple{QuantEcon.DiscreteDP,QuantEcon.DPSolveResult{QuantEcon.PFI,Tval&lt;:Real},Integer,Real,Integer}"><code>QuantEcon._solve!</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Policy Function Iteration</p><p>NOTE: The epsilon is ignored in this method. It is only here so dispatch can       go from <code>solve(::DiscreteDP, ::Type{Algo})</code> to any of the algorithms.       See <code>solve</code> for further details</p></div><a class="source-link" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/tree/f744b5bd0dbe0f65cf0ff32bc5a744948435e4ec/src/markov/ddp.jl#L774-L780">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantEcon._solve!-Tuple{QuantEcon.DiscreteDP,QuantEcon.DPSolveResult{QuantEcon.VFI,Tval&lt;:Real},Integer,Real,Integer}" href="#QuantEcon._solve!-Tuple{QuantEcon.DiscreteDP,QuantEcon.DPSolveResult{QuantEcon.VFI,Tval&lt;:Real},Integer,Real,Integer}"><code>QuantEcon._solve!</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Impliments Value Iteration NOTE: See <code>solve</code> for further details</p></div><a class="source-link" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/tree/f744b5bd0dbe0f65cf0ff32bc5a744948435e4ec/src/markov/ddp.jl#L745-L748">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantEcon.fix" href="#QuantEcon.fix"><code>QuantEcon.fix</code></a> — <span class="docstring-category">Function</span>.</div><div><p><code>fix(x)</code></p><p>Round <code>x</code> towards zero. For arrays there is a mutating version <code>fix!</code></p></div><a class="source-link" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/tree/f744b5bd0dbe0f65cf0ff32bc5a744948435e4ec/src/util.jl#L16-L20">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantEcon.getZ-Tuple{Array{T,2},Float64,Array{T,2}}" href="#QuantEcon.getZ-Tuple{Array{T,2},Float64,Array{T,2}}"><code>QuantEcon.getZ</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Simple method to return an element <span>$Z$</span> in the Riccati equation solver whose type is Matrix (to be accepted by the <code>cond()</code> function)</p><p><strong>Arguments</strong></p><ul><li><p><code>BB::Matrix</code> : result of <span>$B&#39; B$</span></p></li><li><p><code>gamma::Float64</code> : parameter in the Riccati equation solver</p></li><li><p><code>R::Matrix</code></p></li></ul><p><strong>Returns</strong></p><ul><li><p><code>::Matrix</code> : element <span>$Z$</span> in the Riccati equation solver</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/tree/f744b5bd0dbe0f65cf0ff32bc5a744948435e4ec/src/matrix_eqn.jl#L209">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantEcon.getZ-Tuple{Float64,Float64,Float64}" href="#QuantEcon.getZ-Tuple{Float64,Float64,Float64}"><code>QuantEcon.getZ</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Simple method to return an element <span>$Z$</span> in the Riccati equation solver whose type is <code>Float64</code> (to be accepted by the <code>cond()</code> function)</p><p><strong>Arguments</strong></p><ul><li><p><code>BB::Float64</code> : result of <span>$B&#39; B$</span></p></li><li><p><code>gamma::Float64</code> : parameter in the Riccati equation solver</p></li><li><p><code>R::Float64</code></p></li></ul><p><strong>Returns</strong></p><ul><li><p><code>::Float64</code> : element <span>$Z$</span> in the Riccati equation solver</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/tree/f744b5bd0dbe0f65cf0ff32bc5a744948435e4ec/src/matrix_eqn.jl#L179">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantEcon.getZ-Tuple{Float64,Float64,Union{Array{T,1},Array{T,2}}}" href="#QuantEcon.getZ-Tuple{Float64,Float64,Union{Array{T,1},Array{T,2}}}"><code>QuantEcon.getZ</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Simple method to return an element <span>$Z$</span> in the Riccati equation solver whose type is <code>Float64</code> (to be accepted by the <code>cond()</code> function)</p><p><strong>Arguments</strong></p><ul><li><p><code>BB::Union{Vector, Matrix}</code> : result of <span>$B&#39; B$</span></p></li><li><p><code>gamma::Float64</code> : parameter in the Riccati equation solver</p></li><li><p><code>R::Float64</code></p></li></ul><p><strong>Returns</strong></p><ul><li><p><code>::Float64</code> : element <span>$Z$</span> in the Riccati equation solver</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/tree/f744b5bd0dbe0f65cf0ff32bc5a744948435e4ec/src/matrix_eqn.jl#L194">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantEcon.gth_solve!-Tuple{Array{T&lt;:Real,2}}" href="#QuantEcon.gth_solve!-Tuple{Array{T&lt;:Real,2}}"><code>QuantEcon.gth_solve!</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Same as <code>gth_solve</code>, but overwrite the input <code>A</code>, instead of creating a copy.</p></div><a class="source-link" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/tree/f744b5bd0dbe0f65cf0ff32bc5a744948435e4ec/src/markov/mc_tools.jl#L116-L119">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantEcon.random_probvec-Tuple{Integer,Integer}" href="#QuantEcon.random_probvec-Tuple{Integer,Integer}"><code>QuantEcon.random_probvec</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Return <code>m</code> randomly sampled probability vectors of size <code>k</code>.</p><p><strong>Arguments</strong></p><ul><li><p><code>k::Integer</code> : Size of each probability vector.</p></li><li><p><code>m::Integer</code> : Number of probability vectors.</p></li></ul><p><strong>Returns</strong></p><ul><li><p><code>a::Array</code> : Array of shape <code>(k, m)</code> containing probability vectors as columns.</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/tree/f744b5bd0dbe0f65cf0ff32bc5a744948435e4ec/src/markov/random_mc.jl#L200-L212">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantEcon.s_wise_max!-Tuple{AbstractArray{T,2},Array{T,1},Array{T,1}}" href="#QuantEcon.s_wise_max!-Tuple{AbstractArray{T,2},Array{T,1},Array{T,1}}"><code>QuantEcon.s_wise_max!</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Populate <code>out</code> with  <code>max_a vals(s, a)</code>,  where <code>vals</code> is represented as a <code>AbstractMatrix</code> of size <code>(num_states, num_actions)</code>.</p><p>Also fills <code>out_argmax</code> with the column number associated with the <code>indmax</code> in each row</p></div><a class="source-link" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/tree/f744b5bd0dbe0f65cf0ff32bc5a744948435e4ec/src/markov/ddp.jl#L581-L587">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantEcon.s_wise_max!-Tuple{AbstractArray{T,2},Array{T,1}}" href="#QuantEcon.s_wise_max!-Tuple{AbstractArray{T,2},Array{T,1}}"><code>QuantEcon.s_wise_max!</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Populate <code>out</code> with  <code>max_a vals(s, a)</code>,  where <code>vals</code> is represented as a <code>AbstractMatrix</code> of size <code>(num_states, num_actions)</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/tree/f744b5bd0dbe0f65cf0ff32bc5a744948435e4ec/src/markov/ddp.jl#L575-L578">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantEcon.s_wise_max!-Tuple{Array{T,1},Array{T,1},Array{T,1},Array{T,1},Array{T,1}}" href="#QuantEcon.s_wise_max!-Tuple{Array{T,1},Array{T,1},Array{T,1},Array{T,1},Array{T,1}}"><code>QuantEcon.s_wise_max!</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Populate <code>out</code> with  <code>max_a vals(s, a)</code>,  where <code>vals</code> is represented as a <code>Vector</code> of size <code>(num_sa_pairs,)</code>.</p><p>Also fills <code>out_argmax</code> with the cartesiean index associated with the <code>indmax</code> in each row</p></div><a class="source-link" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/tree/f744b5bd0dbe0f65cf0ff32bc5a744948435e4ec/src/markov/ddp.jl#L641-L647">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantEcon.s_wise_max!-Tuple{Array{T,1},Array{T,1},Array{T,1},Array{T,1}}" href="#QuantEcon.s_wise_max!-Tuple{Array{T,1},Array{T,1},Array{T,1},Array{T,1}}"><code>QuantEcon.s_wise_max!</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Populate <code>out</code> with  <code>max_a vals(s, a)</code>,  where <code>vals</code> is represented as a <code>Vector</code> of size <code>(num_sa_pairs,)</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/tree/f744b5bd0dbe0f65cf0ff32bc5a744948435e4ec/src/markov/ddp.jl#L620-L623">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantEcon.s_wise_max-Tuple{AbstractArray{T,2}}" href="#QuantEcon.s_wise_max-Tuple{AbstractArray{T,2}}"><code>QuantEcon.s_wise_max</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Return the <code>Vector</code> <code>max_a vals(s, a)</code>,  where <code>vals</code> is represented as a <code>AbstractMatrix</code> of size <code>(num_states, num_actions)</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/tree/f744b5bd0dbe0f65cf0ff32bc5a744948435e4ec/src/markov/ddp.jl#L569-L572">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantEcon.todense-Tuple{Type,Array}" href="#QuantEcon.todense-Tuple{Type,Array}"><code>QuantEcon.todense</code></a> — <span class="docstring-category">Method</span>.</div><div><p>If <code>A</code> is already dense, return <code>A</code> as is</p></div><a class="source-link" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/tree/f744b5bd0dbe0f65cf0ff32bc5a744948435e4ec/src/markov/mc_tools.jl#L290">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantEcon.todense-Tuple{Type,SparseMatrixCSC}" href="#QuantEcon.todense-Tuple{Type,SparseMatrixCSC}"><code>QuantEcon.todense</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Custom version of <code>full</code>, which allows convertion to type <code>T</code></p></div><a class="source-link" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/tree/f744b5bd0dbe0f65cf0ff32bc5a744948435e4ec/src/markov/mc_tools.jl#L276">source</a><br/></section><footer><hr/><a class="previous" href="../index.html"><span class="direction">Previous</span><span class="title">Home</span></a><a class="next" href="../man/contributing.html"><span class="direction">Next</span><span class="title">Contributing</span></a></footer></article></body></html>
